<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-02 Fri 18:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="case" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org64947df">1. 4Clojure Problems</a>
<ul>
<li><a href="#orgccb814e">1.1. #33 Replicate a Sequence</a></li>
<li><a href="#org836bbc8">1.2. #45 Intro to Iterate</a></li>
<li><a href="#org56b0544">1.3. #47 Contain Yourself</a></li>
<li><a href="#org3a244e4">1.4. [[https://www.4clojure.com/problem/31][#31 Pack a Sequence</a></li>
<li><a href="#orgf23b6e8">1.5. #40 Interpose a Sequence</a></li>
<li><a href="#org2e1c9d4">1.6. #41 Drop Every Nth Item</a></li>
</ul>
</li>
<li><a href="#orgf47b8bd">2. SICMutils</a></li>
</ul>
</div>
</div>
<div id="outline-container-org64947df" class="outline-2">
<h2 id="org64947df"><span class="section-number-2">1</span> 4Clojure Problems</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgccb814e" class="outline-3">
<h3 id="orgccb814e"><span class="section-number-3">1.1</span> <a href="https://www.4clojure.com/problem/33">#33 Replicate a Sequence</a></h3>
<div class="outline-text-3" id="text-1-1">
<p>
This initially made me think about the <code>dotimes</code> function however <code>do times</code> takes an n variable and ranges from 0 to n. Instead I used <code>repeat</code> to and <code>take</code> to build a basic understanding of the problem.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span>flatten <span style="color: #FFB8D1;">(</span>take <span style="color: #C5A3FF; font-weight: bold;">4</span> <span style="color: #C2FFDF;">(</span>repeat <span style="color: #C5A3FF; font-weight: bold;">4</span> <span style="color: #E6C000;">[</span><span style="color: #C5A3FF;">:a</span><span style="color: #E6C000;">]</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (:a :a :a :a)</span>
</pre>
</div>
<p>
One approach could be to map across the entire sequence.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>coll n<span style="color: #C2FFDF;">]</span>
  <span style="color: #C2FFDF;">(</span>flatten <span style="color: #E6C000;">(</span>map <span style="color: #C5A3FF;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #FFEA00;">[</span>x<span style="color: #FFEA00;">]</span> <span style="color: #FFEA00;">(</span>take n <span style="color: #8295D6;">(</span>repeat n x<span style="color: #8295D6;">)</span><span style="color: #FFEA00;">)</span><span style="color: #C5A3FF;">)</span> coll<span style="color: #E6C000;">)</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF;">:a</span> <span style="color: #C5A3FF;">:b</span><span style="color: #FFB8D1;">]</span> <span style="color: #C5A3FF; font-weight: bold;">4</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (:a :a :a :a :b :b :b :b)</span>
</pre>
</div>
<p>
However it should also be possible to use <code>reduce</code> and perhaps drop the <code>flatten</code> function.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>coll n<span style="color: #C2FFDF;">]</span>
  <span style="color: #C2FFDF;">(</span>reduce <span style="color: #E6C000;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C5A3FF;">[</span>f s<span style="color: #C5A3FF;">]</span>
            <span style="color: #C5A3FF;">(</span>apply conj f <span style="color: #FFEA00;">(</span>take n <span style="color: #8295D6;">(</span>repeat n s<span style="color: #8295D6;">)</span><span style="color: #FFEA00;">)</span><span style="color: #C5A3FF;">)</span><span style="color: #E6C000;">)</span>
          <span style="color: #E6C000;">[]</span>
          coll<span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF;">:a</span> <span style="color: #C5A3FF;">:b</span><span style="color: #FFB8D1;">]</span> <span style="color: #C5A3FF; font-weight: bold;">4</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; [:a :a :a :a :b :b :b :b]</span>
</pre>
</div>
<p>
The brilliant apply step shown above is referenced from a <a href="https://github.com/morrxy/4clojure/blob/master/problem/33.Replicate%20a%20Sequence.clj">solution</a> online and here it is helpful to see apply as a way to push conj into the the following sequence, e.g. without the apply the output is <code>[(:a :a :a :a) (:b :b :b :b)]</code>, and apply can be seen as applying conj to the inner parens <code>(conj :a :a :a :a)</code> rather than <code>(conj (:a :a :a :a))</code>
In the same link above is the solution <code>(fn [s n] (mapcat (partial repeat n) s))</code> highlights a really perfect use of <code>partial</code> (functional thinking in action!) and introduces me to <code>mapcat</code>. I now wonder if I can apply the <code>partial</code> function to more of my solutions as a way of practicing a kind of encapsulation without writing separate helper functions (a kind of internal encapsulation).
</p>
</div>
</div>
<div id="outline-container-org836bbc8" class="outline-3">
<h3 id="org836bbc8"><span class="section-number-3">1.2</span> <a href="https://www.4clojure.com/problem/45">#45 Intro to Iterate</a></h3>
<div class="outline-text-3" id="text-1-2">
<p>
What I thought iterate would output is <code>(4 4 4 4 4)</code>, that is, just taking the function and making an infinite sequence out of it. What it actually outputs is <code>(1 4 7 10 13)</code> which is x, f(x), f(f(x), f(f(f(x))), etc. This very much looks like a versatile variation of <code>reduce</code> and I wonder if previous examples could be solved with it (for example #33 Replicate a sequence).
A quick first attempt to see what iterate would look like gives me the impression that since iterate returns the first input as a result that this will either have to be stripped away, buuuut it does make me think of the fibonacci sequence where the initial values are a good candidate for the output
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span>take <span style="color: #C5A3FF; font-weight: bold;">5</span> <span style="color: #FFB8D1;">(</span>iterate #<span style="color: #C2FFDF;">(</span>+ <span style="color: #C5A3FF; font-weight: bold;">3</span> <span style="color: #FFB8D1;">%</span><span style="color: #C2FFDF;">)</span> <span style="color: #C5A3FF; font-weight: bold;">1</span><span style="color: #FFB8D1;">)</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 4 7 10 13)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span>take <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #FFB8D1;">(</span>iterate #<span style="color: #C2FFDF;">(</span>repeat <span style="color: #C5A3FF; font-weight: bold;">4</span> <span style="color: #FFB8D1;">%</span><span style="color: #C2FFDF;">)</span> <span style="color: #C2FFDF;">[</span><span style="color: #C5A3FF;">:a</span> <span style="color: #C5A3FF;">:b</span><span style="color: #C2FFDF;">]</span><span style="color: #FFB8D1;">)</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; ([:a :b] ([:a :b] [:a :b] [:a :b] [:a :b]))</span>

<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">fib attempt</span>
<span style="color: #55b3cc;">(</span>take <span style="color: #C5A3FF; font-weight: bold;">5</span> <span style="color: #FFB8D1;">(</span>iterate #<span style="color: #C2FFDF;">(</span>+ <span style="color: #FFB8D1;">%</span> <span style="color: #FFB8D1;">%</span><span style="color: #C2FFDF;">)</span> <span style="color: #C5A3FF; font-weight: bold;">1</span><span style="color: #FFB8D1;">)</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 2 4 8 16)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 2 3 4 5)</span>

<span style="color: #55b3cc;">(</span>#<span style="color: #FFB8D1;">(</span>take <span style="color: #FFB8D1;">%</span> <span style="color: #C2FFDF;">(</span>iterate <span style="color: #E6C000;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C5A3FF;">[</span><span style="color: #FFEA00;">[</span>a b<span style="color: #FFEA00;">]</span><span style="color: #C5A3FF;">]</span> <span style="color: #C5A3FF;">[</span>b <span style="color: #FFEA00;">(</span>+ a b<span style="color: #FFEA00;">)</span><span style="color: #C5A3FF;">]</span><span style="color: #E6C000;">)</span> <span style="color: #E6C000;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">1</span><span style="color: #E6C000;">]</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> <span style="color: #C5A3FF; font-weight: bold;">8</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; ([1 1] [1 2] [2 3] [3 5] [5 8] [8 13] [13 21] [21 34])</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 1 2 3 5 8 13 21) after adding map first</span>

<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">first I don't think I understand the destructuring</span>
<span style="color: #55b3cc;">(</span><span style="color: #96CBFE; font-style: italic;">let</span> <span style="color: #FFB8D1;">[</span><span style="color: #C2FFDF;">[</span>a b<span style="color: #C2FFDF;">]</span> <span style="color: #C2FFDF;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #C2FFDF;">]</span><span style="color: #FFB8D1;">]</span>
   <span style="color: #FFB8D1;">(</span>str a <span style="color: #FFEA00;">" "</span> b<span style="color: #FFB8D1;">)</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; "1 3"</span>
</pre>
</div>
<p>
   This keeps catching me out, when a vector is destructured to a vector the values are mapped to corresponding variable names so the above fib variation with iterate looks like return the vector that consists of the second input variable as the first result and the second result is the first input plus the second input, then feed that resulting vector into the same function so [1 1] -&gt; [1 2] -&gt; [2 3] -&gt; [3 5] -&gt; [5 8]
I suppose the discover fiction might have gone like:
</p>
<ol class="org-ol">
<li>first think about explaining exactly what the fib sequence is doing and pretend that there is a way to feed outputs of functions back to themselves iteratively.</li>
<li>then somehow one has to know that the iterate function is exactly what fits that imagined patter (of course pure recursion is probably the simpler approach) but given that iterate does exist then map first through that generated sequence.
For the discovery process to work it's important to think like feynman when he says It's ok not to know everything. Just move forward with the abstraction and take note of where you are stuck, the mind will create a kind of sieve that will make the solution pop out eventually!</li>
</ol>
</div>
</div>
<div id="outline-container-org56b0544" class="outline-3">
<h3 id="org56b0544"><span class="section-number-3">1.3</span> <a href="https://www.4clojure.com/problem/47">#47 Contain Yourself</a></h3>
<div class="outline-text-3" id="text-1-3">
<p>
Using <code>contains?</code> on an indexed sequence takes the second argument to literally mean is index n in the sequence. However when used on a map or a map-like structure then <code>contains?</code> looks to see if the KEY is in the collection. Fun fact, I did not know until this exercise that a set is a map-like collection  but this makes sense to me in that a set can be thought of as a collection of keys, so key comparisons in <code>contains</code> returns true if key is in set.
</p>
</div>
</div>
<div id="outline-container-org3a244e4" class="outline-3">
<h3 id="org3a244e4"><span class="section-number-3">1.4</span> [[<a href="https://www.4clojure.com/problem/31">https://www.4clojure.com/problem/31</a>][#31 Pack a Sequence</h3>
<div class="outline-text-3" id="text-1-4">
<p>
   ]]Pack consecutive duplicates into sub-lists
This was so simple since I've had some experience with partition-by in the past. It's a good example of when the <code>identity</code> function is valuable (hard to imagine when just coming across it for the first time!)
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span>partition-by identity <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">3</span> <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf23b6e8" class="outline-3">
<h3 id="orgf23b6e8"><span class="section-number-3">1.5</span> <a href="https://www.4clojure.com/problem/40">#40 Interpose a Sequence</a></h3>
<div class="outline-text-3" id="text-1-5">
<p>
Without the function interpose, here is my first attempt. Still some effort involved to remember that any time I see a function applied to each index in a seq then the first thought should be map. This seems like there could be a more elegant solution, in particular I'm not fond of the <code>flatten</code> seems like there could be a simpler answer
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>v coll<span style="color: #C2FFDF;">]</span>
   <span style="color: #C2FFDF;">(</span>flatten <span style="color: #E6C000;">(</span>map <span style="color: #C5A3FF;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #FFEA00;">[</span>x<span style="color: #FFEA00;">]</span> <span style="color: #FFEA00;">(</span>conj <span style="color: #8295D6;">[]</span> x v<span style="color: #FFEA00;">)</span><span style="color: #C5A3FF;">)</span> coll<span style="color: #E6C000;">)</span><span style="color: #C2FFDF;">)</span> <span style="color: #FFB8D1;">)</span> <span style="color: #C5A3FF;">:z</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF;">:a</span> <span style="color: #C5A3FF;">:b</span> <span style="color: #C5A3FF;">:c</span> <span style="color: #C5A3FF;">:d</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (:a :z :b :z :c :z :d :z)</span>
</pre>
</div>
<p>
&#x2026;on closer inspection it seems like I got this one wrong, the last term should not be added, so the problem is to add something within the range of the collection&#x2026;hmmm
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>v coll<span style="color: #C2FFDF;">]</span>
   <span style="color: #C2FFDF;">(</span>butlast <span style="color: #E6C000;">(</span>flatten <span style="color: #C5A3FF;">(</span>map <span style="color: #FFEA00;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #8295D6;">[</span>x<span style="color: #8295D6;">]</span> <span style="color: #8295D6;">(</span>conj <span style="color: #a2b6da;">[]</span> x v<span style="color: #8295D6;">)</span><span style="color: #FFEA00;">)</span> coll<span style="color: #C5A3FF;">)</span><span style="color: #E6C000;">)</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> <span style="color: #C5A3FF; font-weight: bold;">0</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 0 2 0 3)</span>
</pre>
</div>
<p>
&#x2026;so now I am definitely suspicious that this is not as elegant as is possible so lets look at some other solutions to learn from them. Looks like I'm not alone in my approach but two other approaches interest me in that they introduce <code>interleave</code> and also use <code>reduce</code> (which is also seems like a pattern, anything map can do reduce can do better!). Looking at reduce first:
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #E6C000;">;; </span><span style="color: #E6C000;">reduce here is using an accumulator which is a common pattern</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">lets start with the naive implementation</span>
<span style="color: #55b3cc;">(</span>reduce <span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>acc x<span style="color: #C2FFDF;">]</span> <span style="color: #C2FFDF;">(</span>conj acc x <span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span>
        <span style="color: #FFB8D1;">[]</span>
        <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; [1 0 2 0 3 0]</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">so we can get rid of the flatten with reduce however</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">it does look like we're stuck with either droplast or butlast</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">Other solutions show us how to drop the flatten with mapcat</span>
<span style="color: #55b3cc;">(</span>mapcat <span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>x<span style="color: #C2FFDF;">]</span> <span style="color: #C2FFDF;">(</span>list x <span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span><span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 0 2 0 3 0)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">this is a good example of getting rid of flatten and still</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">keeping the simplicity of map but also it's nice to note that</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">the list function is a very simple way to make two things that</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">are not a collection into a list collection, this should be the</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">goto instead of fidgeting around with cons, conj, and into...</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">finally let's look at interleave</span>
<span style="color: #55b3cc;">(</span>#<span style="color: #FFB8D1;">(</span>interleave <span style="color: #FFB8D1;">%</span> <span style="color: #C2FFDF;">(</span>repeat <span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 0 2 0 3 0)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">I really like this solution because the concept of using</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">repeat as a generative collection that simply produces a result as</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">they are needed seems succinct and powerful. It's also a way of thinking</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">that is foreign to me and so using it and seeing it really helps imagine</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">concrete use cases (or rather I believe it will make me more likely to apply</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">it in the future!)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2e1c9d4" class="outline-3">
<h3 id="org2e1c9d4"><span class="section-number-3">1.6</span> <a href="https://www.4clojure.com/problem/41">#41 Drop Every Nth Item</a></h3>
<div class="outline-text-3" id="text-1-6">
<p>
Given coll and N drop ever N from coll
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #55b3cc;">(</span><span style="color: #96CBFE; font-style: italic;">def</span> <span style="color: #FFB8D1;">coll</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">1</span> <span style="color: #C5A3FF; font-weight: bold;">2</span> <span style="color: #C5A3FF; font-weight: bold;">3</span> <span style="color: #C5A3FF; font-weight: bold;">4</span> <span style="color: #C5A3FF; font-weight: bold;">5</span> <span style="color: #C5A3FF; font-weight: bold;">6</span> <span style="color: #C5A3FF; font-weight: bold;">7</span> <span style="color: #C5A3FF; font-weight: bold;">8</span><span style="color: #FFB8D1;">]</span><span style="color: #55b3cc;">)</span>
<span style="color: #55b3cc;">(</span>partition <span style="color: #C5A3FF; font-weight: bold;">3</span> coll<span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; ((1 2 3) (4 5 6))</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">oops this drops the last group if it is smaller than 3!</span>
<span style="color: #55b3cc;">(</span>partition-all <span style="color: #C5A3FF; font-weight: bold;">3</span> coll<span style="color: #55b3cc;">)</span><span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; ((1 2 3) (4 5 6) (7 8))</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">partition-all gives us the remaining partition even if it's size is too</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">small but we need to uniformly apply butlast to all so we need to pad instead</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">partition takes a n items, a step size which usually defaults to n, a padding</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">which here we use the vector of zero arbitrarily and the collection! perfect!</span>
<span style="color: #55b3cc;">(</span>partition <span style="color: #C5A3FF; font-weight: bold;">3</span> <span style="color: #C5A3FF; font-weight: bold;">3</span> <span style="color: #FFB8D1;">[</span><span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #FFB8D1;">]</span> coll<span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; ((1 2 3) (4 5 6) (7 8 0))</span>
<span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>c n<span style="color: #C2FFDF;">]</span>
   <span style="color: #C2FFDF;">(</span>mapcat butlast <span style="color: #E6C000;">(</span>partition n n <span style="color: #C5A3FF;">[</span><span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #C5A3FF;">]</span> c<span style="color: #E6C000;">)</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> coll <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #55b3cc;">)</span><span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 2 4 5 7 8)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">I bet there is a way to use reduce</span>
<span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>c n<span style="color: #C2FFDF;">]</span>
   <span style="color: #C2FFDF;">(</span>reduce <span style="color: #E6C000;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C5A3FF;">[</span>acc x<span style="color: #C5A3FF;">]</span> <span style="color: #C5A3FF;">(</span>apply conj acc <span style="color: #FFEA00;">(</span>butlast x<span style="color: #FFEA00;">)</span><span style="color: #C5A3FF;">)</span><span style="color: #E6C000;">)</span>
           <span style="color: #E6C000;">[]</span>
           <span style="color: #E6C000;">(</span>partition n n <span style="color: #C5A3FF;">[</span><span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #C5A3FF;">]</span> c<span style="color: #E6C000;">)</span><span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span> coll <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; [(1 2) (4 5) (7 8)] &lt;-- solution before adding apply</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; [1 2 4 5 7 8]</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">this is so cool because not only is this an alternate solution</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">using reduce, it also applies the apply logic to push the conj</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">into the group so that there is no need for a flatten!</span>
</pre>
</div>
<p>
There are a few other solutions that warrant a closer look:
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #E6C000;">;; </span><span style="color: #E6C000;">keep is like map where nil results are filtered from the final answer</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">keep-indexed is like map-indexed where nil results are filtered and f</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">requires both an index and a value</span>
<span style="color: #55b3cc;">(</span><span style="color: #FFB8D1;">(</span><span style="color: #96CBFE; font-style: italic;">fn</span> <span style="color: #C2FFDF;">[</span>c n<span style="color: #C2FFDF;">]</span>
   <span style="color: #C2FFDF;">(</span>keep-indexed <span style="color: #E6C000;">;; </span><span style="color: #E6C000;">so %1 and %2 below are idx and item of the coll</span>
     #<span style="color: #E6C000;">(</span><span style="color: #96CBFE; font-style: italic;">if</span> <span style="color: #C5A3FF;">(</span>&gt; <span style="color: #FFEA00;">(</span>mod <span style="color: #8295D6;">(</span>inc <span style="color: #FFB8D1;">%1</span><span style="color: #8295D6;">)</span> n<span style="color: #FFEA00;">)</span> <span style="color: #C5A3FF; font-weight: bold;">0</span><span style="color: #C5A3FF;">)</span> <span style="color: #FFB8D1;">%2</span><span style="color: #E6C000;">)</span> c<span style="color: #C2FFDF;">)</span><span style="color: #FFB8D1;">)</span>
 coll <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 2 4 5 7 8)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">if mod is &gt; 0 keep the value in the list, so in this example every 3rd</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">item is kept and the rest are thrown out! A poor mans partition!</span>

<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">the partition-all solution is rather elegant as well</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">partition-all takes a partition size n, a step and a coll</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">partition-all keeps chunks that are smaller than the partition size</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">unlike partition-by which is "wasteful" and drops the extra</span>
<span style="color: #55b3cc;">(</span>partition-all <span style="color: #FFB8D1;">(</span>dec <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #FFB8D1;">)</span> <span style="color: #C5A3FF; font-weight: bold;">3</span> coll<span style="color: #55b3cc;">)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; ((1 2) (4 5) (7 8))</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">then apply concat slides into the groupings and stitches it all</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">back into a flat seq</span>
<span style="color: #55b3cc;">(</span>apply concat <span style="color: #FFB8D1;">(</span>partition-all <span style="color: #C2FFDF;">(</span>dec <span style="color: #C5A3FF; font-weight: bold;">3</span><span style="color: #C2FFDF;">)</span> <span style="color: #C5A3FF; font-weight: bold;">3</span> coll<span style="color: #FFB8D1;">)</span><span style="color: #55b3cc;">)</span><span style="color: #E6C000;">;; </span><span style="color: #E6C000;">=&gt; (1 2 4 5 7 8)</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">i think the key piece is that partition size is 2 for this example</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">and step size is 3 so partion-all steps over the last item effectively</span>
<span style="color: #E6C000;">;; </span><span style="color: #E6C000;">dropping it!</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf47b8bd" class="outline-2">
<h2 id="orgf47b8bd"><span class="section-number-2">2</span> SICMutils</h2>
<div class="outline-text-2" id="text-2">
<p>
**
</p>
<div class="org-src-container">
<pre class="src src-clojure">
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: case</p>
<p class="date">Created: 2021-04-02 Fri 18:27</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
