* 4Clojure Problems
** [[https://www.4clojure.com/problem/21][#21 Nth from seq]]
   My first attempt is a non-functional approach but hey, non-functional thinking that gets to a solution is valid right?
#+begin_src clojure
((fn [coll idx]
   (loop [remain coll
          i      0]
     (if (or (nil? remain) (= idx i)) ; checks to see if seq over, party!
       (first remain)
       (let [[_ & r] remain] ; using destructuring to take rest of remain
         (recur r (inc i)))))) '(4 5 6 7) 2)
;; => 6
(rest '(4 5 6 7))
;; => (5 6 7)
;; so an easy win here is similar but using rest
((fn [coll idx]
   (loop [remain coll
          i      0]
     (if (or (nil? remain) (= idx i)) ; checks to see if seq over, party!
       (first remain)
       (recur (rest remain) (inc i))))) '(4 5 6 7) 2)
;; => 6
;; this at least gets rid of the extra let form
;; a more clever version is
(#(last (take (inc %2) %1)) '(4 5 6 7) 2)
;; => 6
(drop 1 [1 2 3 4]);; => (2 3 4)
;; drop drops from the front, nice
(#(first (drop %2 %1)) '(4 5 6 7) 2)
;; => 6
#+end_src
** [[https://www.4clojure.com/problem/22][#22 Count a sequence]]
   Why not try another loop?
#+begin_src clojure
(#(loop [coll %
         i    0]
    (if (empty? coll)
      i
      (recur (rest coll) (inc i)))) '(1 2 3 3 1))
;; => 5
#+end_src
Some of the solutions seemed pretty advanced to me even after coming back, let's take a look:
#+begin_src clojure
;; using reduce with constantly
(constantly 1)
;; => #function[clojure.core/constantly/fn--5690]
;; huh, this is now a function that takes any number of args and returns 1
((constantly 1) 100 2 3);; => 1
;; a really fascinating way to count a seq is with mapping this function
;; across all values of the sequence and reduce + to accumulate the final value
(reduce + (map (constantly 1) [1 2 3 3 1]));; => 5

;; only incrementing the accumulator in reduce is quite creative!
(#(reduce (fn [a b] (inc a)) 0 %) '(1 2 3 3 1))
;; => 5
#+end_src
** [[https://www.4clojure.com/problem/23][#23 Reverse a sequence]]
   Without using ~reverse~ or ~rseq~ I remember a trick using ~conj~ on a list is supposed to reverse it since lists add at the head and ~into~ uses ~conj~ behind the scenes
#+begin_src clojure
(#(into () %) [1 2 3 4 5])
;; => (5 4 3 2 1)
#+end_src
I think I'm pretty clever here...ha, let's look at some other solutions
#+begin_src clojure
;; reduce conj is another way of saying into
(#(reduce conj () %) [1 2 3 4 5])
;; => (5 4 3 2 1)

;; this is interesting and not immediately obvious to me
(#(reduce
    (fn [rs ls] (cons ls rs)) [] %) [1 2 3 4 5])
;; => (5 4 3 2 1)
(cons 1 []);; => (1)
(cons 2 '(1));; => (2 1)
(cons 3 '(2 1));; => (3 2 1)
;; ok cool, this is the reverse of my method but the same logic of
;; adding a number to the head of a list (reverse as in reverse order
;; this is number first then list my solution is list first then number)
#+end_src
** [[https://www.4clojure.com/problem/25][#25 Return only odd numbers]]
  First attempt and realized that != is not= in clojure
#+begin_src clojure
((fn [s] filter #(not= 0 (mod % 2)) s) '(1 3 5))
;; => (1 3 5)
#+end_src
The code golf and probably the clojure way is:
#+begin_src clojure
(#(filter odd? %) '(1 3 5))
;; => (1 3 5)
#+end_src
** [[https://www.4clojure.com/problem/26][#26 Fibonacci Sequence]]
   Write a function that returns the X numbers in the Fibonacci sequences.

   The Fibonacci sequence is like the hello world of recursion, and for me it's both a difficult and fascinating problem. Not gonna lie this took me a while and to be honest I'm going to have to look at this a few more times for it to really start to feel natural, but writing this in clojure is perhaps the most intuitive, the following are a number of explorations and even this is not inclusive of everything I tried!
#+begin_src clojure
;; most of the time fib sequences are given 1 1 as the start
;; my first thought is to understand how the fib seq is constructed
;; starting with the values 1 1 we add the two together and add the result
;; to the sequence (1 1 2), repeating once more we take the last items from the
;; list and add the result to the list (1 1 2 3) and so on, seems like a ~cons~ style recursion with a take-last add comp, but it looks like comp takes many arguments and I still keep being caught out by the difference between many args and a single collection of args!

;; instead let's see if this chunk can be recursed
(apply + (take-last 2 '(1 2 3)))
;; => 5

(into [1 1] [3])
;; => [1 1 3]
(into [1 1] [[3] [1]])
;; => [1 1 [3] [1]]

;; just writing this down because it seems to be a point of confusion still
;; into is for working from collection to collection

(cons 1 [1 2 3])
;; => (1 1 2 3)
(cons [1] [1 2 3])
;; => ([1] 1 2 3)

;; cons and conj are for building collections
;; cons takes whatever is in the first arg and puts it into the second arg which must be a collection, and cons adds to the beginning

(conj [1] 1)
;; => [1 1]
(conj [1] [1])
;; => [1 [1]]

;; conj takes a collection and adds whatever follows to the collection, if the collection is a list it adds to the beginning and if it is a vector it adds it to the end, so the type of collection matters for placement

;; both cons and conj add entire collections to the sequence preserving the colleciton (see second example on both) where as into takes the inner collection, so when trying to add a collection of collections to a collection then a collection is added, if only trying to add a collection to another collection then the contents of the collection are added...see into examples. I hope this clears this up, I'm not sure why I'm not able to keep these straight but perhaps it's because I see them as so closely related to each other...

((fn fib
   [coll n]
   (conj coll (apply + (take-last 2 coll)))) [1 1] 3)
;; => [1 1 2]

;; the above structure reminds me of something that might be reducible
(reduce (fn [f s] (conj [] f s (+ f s))) [1 1])
;; => [1 1 2]

(reductions (fn [f s] (conj f (apply + (take-last 2 f)))) [1 1] (range 5))
;; => ([1 1] [1 1 2] [1 1 2 3] [1 1 2 3 5] [1 1 2 3 5 8] [1 1 2 3 5 8 13])
;; => ([1 1] [1 1 2] [1 1 2 4] [1 1 2 4 8] [1 1 2 4 8 16] [1 1 2 4 8 16 32])
;; => [1 1 2 4 8 16 32]

;; brilliant! and it only took me 12 days! learned about using ~reductions~ to
;; see the intermediate steps and also about debugging in cider by setting a
;; breakpoint with , d b and stepping through the evaluation, super handy and
;; worth the extra time spent. Also of note, took a break to run and shower
;; had lunch while looking over the problem and boom, answer. Note to self:
;; it is ok and often beneficial to step away for a moment (not the first time
;; I've had to remind myself of this miraculous life-hack)

;; final answer for 4clojure's purposes
(#(reduce (fn [f s] (conj f (apply + (take-last 2 f)))) [1 1] (range (- % 2))) 5)
;; => [1 1 2 3 5]

(#(reduce (fn [f s] (conj f (apply + (drop s f)))) [1 1] (range (- % 2))) 5)
;; => [1 1 2 3 5]

(#(reduce (fn [f s] (conj f (apply + (drop s f)))) [1 1] (range (- % 2))) 7)
;; => [1 1 2 3 5 8 13]

;; as an added bonus the above also takes care of the more generalized version
;; of the fibonacci seq if the starting vector is given as [0 1]

;; I have to admit this is the second time that I've come across this fib problem
;; in 4clojure and I thought I would try to refresh my memory by approaching it
;; again with my slightly more mature knowledge of the core library my first
;; solution is as follows:

((fn [n]
   (loop [m [1 1]]
     (if (>= (count m) n)
       m
       (recur (conj m (+ (last m) (last (butlast m)))))))) 5)
;; => [1 1 2 3 5]

;; which looks like almost exactly the same internal logic of somehow
;; add the starting vector to a collection and then take the last and the
;; second last add them and then conj into the rolling collection.

;; Here we see that I have put a block to essentially return the starting vector
;; if n is less than 3 but then I return the starting vector, which is wrong for
;; n 0,1,2. My solution only works for n > 3, so instead I can add take n as
;; follows

((fn [n]
   (loop [m [1 1]]
     (if (>= (count m) n)
       (take n m)
       (recur (conj m (+ (last m) (last (butlast m)))))))) 3)
;; => (1 1 2) n = 3
;; => (1 1)   n = 2
;; => (1)     n = 1
;; => ()      n = 0

;; probably my favorite solution:
(#(take % ((fn fib [f s] (lazy-seq (cons f (fib s (+ s f))))) 1 1)) 5)
;; => (1 1 2 3 5)
;; which looks like:
;; fib [1 1] | fib [1 2] | fib [2 3] | fib [3 5] | fib [5 8] |
;;  (cons 1     (cons 1     (cons 2     (cons 4      (cons 5 (empty) )))))
;; which recursively reduces down as below: read right to left
;; (1 1 2 3 5)  (1 3 4 5)   (2 3 5)     (3 5)        (5)
;;
;; the ~lazy-seq~ part still feels like magic but I know engough about it
;; to know that it's used with something like ~take~

;; the final solution that I'll look at here is one with ~iterate~
;; iterate is an important function that again produces a lazy seq
;; given a function and it's arguments
;; (x,f(x),f(f(x)),f(f(f(x))),f(f(f(f(x))))...etc)
;; what's nice about the fib seq is that it's logic is simple
(fn [[x1 x2]] [x2 (+ x1 x2)])
;; which very simply translates to given two arguments, return a vector
;; containing the second arg first and the summation of both args as the
;; second index. Putting this into iterate gives us:
(take 5 (iterate (fn [[x1 x2]] [x2 (+ x1 x2)]) [1 1]))
;; => ([1 1] [1 2] [2 3] [3 5] [5 8])
;; which gives us a sequence where if we squint we can see the fib in
;; the first index of each vector, to extract that we map
(map first (take 5 (iterate (fn [[x1 x2]] [x2 (+ x1 x2)]) [1 1])))
;; => (1 1 2 3 5)
#+end_src
And honestly, that's all I can take for the fibonacci sequence. While it is a fascinating problem it also is something that would help if I threw some of the key concepts into a space repetition deck, revisiting more than a few more times will certainly allow for more familiarity.
** [[https://www.4clojure.com/problem/27][#27 Palindrome Detector]]
   I feel like my answer is cheating since I'm only checking if the first and last items match, but it passes!
#+begin_src clojure
(#(let [v %]
    (= (first v) (last v))) '(1 1 1 3 3 1 1 1))
;; => true
#+end_src
So here are the honest solutions
#+begin_src clojure
;; this first solution uses reverse which is probably a great function to know about
(#(= (seq %) (reverse (seq %))) "racecar")
;; => true
;; here seq is used to force a string into a collection, otherwise
;; "racecar" ->  '(\r \a \c \e \c \a \r)
#+end_src
:
** [[https://www.4clojure.com/problem/31][#31 Pack a Sequence]]
   Pack consecutive duplicates into sub-lists
This was so simple since I've had some experience with partition-by in the past. It's a good example of when the ~identity~ function is valuable (hard to imagine when just coming across it for the first time!)
#+begin_src clojure
(partition-by identity [1 1 2 1 1 1 3 3])
#+end_src
** [[https://www.4clojure.com/problem/33][#33 Replicate a Sequence]]
   This initially made me think about the ~dotimes~ function however ~do times~ takes an n variable and ranges from 0 to n. Instead I used ~repeat~ to and ~take~ to build a basic understanding of the problem.
#+begin_src clojure :results silent
  (flatten (take 4 (repeat 4 [:a])))
  ;; => (:a :a :a :a)
#+end_src
    One approach could be to map across the entire sequence.
#+begin_src clojure
  ((fn [coll n]
    (flatten (map (fn [x] (take n (repeat n x))) coll))) [:a :b] 4)
  ;; => (:a :a :a :a :b :b :b :b)
#+end_src
   However it should also be possible to use ~reduce~ and perhaps drop the ~flatten~ function.
#+begin_src clojure
  ((fn [coll n]
    (reduce (fn [f s]
              (apply conj f (take n (repeat n s))))
            []
            coll)) [:a :b] 4)
  ;; => [:a :a :a :a :b :b :b :b]
#+end_src
   The brilliant apply step shown above is referenced from a [[https://github.com/morrxy/4clojure/blob/master/problem/33.Replicate%20a%20Sequence.clj][solution]] online and here it is helpful to see apply as a way to push conj into the the following sequence, e.g. without the apply the output is ~[(:a :a :a :a) (:b :b :b :b)]~, and apply can be seen as applying conj to the inner parens ~(conj :a :a :a :a)~ rather than ~(conj (:a :a :a :a))~
   In the same link above is the solution ~(fn [s n] (mapcat (partial repeat n) s))~ highlights a really perfect use of ~partial~ (functional thinking in action!) and introduces me to ~mapcat~. I now wonder if I can apply the ~partial~ function to more of my solutions as a way of practicing a kind of encapsulation without writing separate helper functions (a kind of internal encapsulation).
** [[https://www.4clojure.com/problem/40][#40 Interpose a Sequence]]
   Without the function interpose, here is my first attempt. Still some effort involved to remember that any time I see a function applied to each index in a seq then the first thought should be map. This seems like there could be a more elegant solution, in particular I'm not fond of the ~flatten~ seems like there could be a simpler answer
#+begin_src clojure
((fn [v coll]
   (flatten (map (fn [x] (conj [] x v)) coll)) ) :z [:a :b :c :d])
;; => (:a :z :b :z :c :z :d :z)
#+end_src
 ...on closer inspection it seems like I got this one wrong, the last term should not be added, so the problem is to add something within the range of the collection...hmmm
#+begin_src clojure
((fn [v coll]
   (butlast (flatten (map (fn [x] (conj [] x v)) coll)))) 0 [1 2 3])
;; => (1 0 2 0 3)
#+end_src
...so now I am definitely suspicious that this is not as elegant as is possible so lets look at some other solutions to learn from them. Looks like I'm not alone in my approach but two other approaches interest me in that they introduce ~interleave~ and also use ~reduce~ (which is also seems like a pattern, anything map can do reduce can do better!). Looking at reduce first:
#+begin_src clojure
;; reduce here is using an accumulator which is a common pattern
;; lets start with the naive implementation
(reduce (fn [acc x] (conj acc x 0))
        []
        [1 2 3])
;; => [1 0 2 0 3 0]
;; so we can get rid of the flatten with reduce however
;; it does look like we're stuck with either droplast or butlast
;; Other solutions show us how to drop the flatten with mapcat
(mapcat (fn [x] (list x 0)) [1 2 3]);; => (1 0 2 0 3 0)
;; this is a good example of getting rid of flatten and still
;; keeping the simplicity of map but also it's nice to note that
;; the list function is a very simple way to make two things that
;; are not a collection into a list collection, this should be the
;; goto instead of fidgeting around with cons, conj, and into...
;; finally let's look at interleave
(#(interleave % (repeat 0)) [1 2 3])
;; => (1 0 2 0 3 0)
;; I really like this solution because the concept of using
;; repeat as a generative collection that simply produces a result as
;; they are needed seems succinct and powerful. It's also a way of thinking
;; that is foreign to me and so using it and seeing it really helps imagine
;; concrete use cases (or rather I believe it will make me more likely to apply
;; it in the future!)
#+end_src

** [[https://www.4clojure.com/problem/41][#41 Drop Every Nth Item]]
   Given coll and N drop ever N from coll
#+begin_src clojure
(def coll [1 2 3 4 5 6 7 8])
(partition 3 coll)
;; => ((1 2 3) (4 5 6))
;; oops this drops the last group if it is smaller than 3!
(partition-all 3 coll);; => ((1 2 3) (4 5 6) (7 8))
;; partition-all gives us the remaining partition even if it's size is too
;; small but we need to uniformly apply butlast to all so we need to pad instead
;; partition takes a n items, a step size which usually defaults to n, a padding
;; which here we use the vector of zero arbitrarily and the collection! perfect!
(partition 3 3 [0] coll)
;; => ((1 2 3) (4 5 6) (7 8 0))
((fn [c n]
   (mapcat butlast (partition n n [0] c))) coll 3);; => (1 2 4 5 7 8)
;; I bet there is a way to use reduce
((fn [c n]
   (reduce (fn [acc x] (apply conj acc (butlast x)))
           []
           (partition n n [0] c))) coll 3)
;; => [(1 2) (4 5) (7 8)] <-- solution before adding apply
;; => [1 2 4 5 7 8]
;; this is so cool because not only is this an alternate solution
;; using reduce, it also applies the apply logic to push the conj
;; into the group so that there is no need for a flatten!
#+end_src
There are a few other solutions that warrant a closer look:
#+begin_src clojure
;; keep is like map where nil results are filtered from the final answer
;; keep-indexed is like map-indexed where nil results are filtered and f
;; requires both an index and a value
((fn [c n]
   (keep-indexed ;; so %1 and %2 below are idx and item of the coll
     #(if (> (mod (inc %1) n) 0) %2) c))
 coll 3)
;; => (1 2 4 5 7 8)
;; if mod is > 0 keep the value in the list, so in this example every 3rd
;; item is kept and the rest are thrown out! A poor mans partition!

;; the partition-all solution is rather elegant as well
;; partition-all takes a partition size n, a step and a coll
;; partition-all keeps chunks that are smaller than the partition size
;; unlike partition-by which is "wasteful" and drops the extra
(partition-all (dec 3) 3 coll)
;; => ((1 2) (4 5) (7 8))
;; then apply concat slides into the groupings and stitches it all
;; back into a flat seq
(apply concat (partition-all (dec 3) 3 coll));; => (1 2 4 5 7 8)
;; i think the key piece is that partition size is 2 for this example
;; and step size is 3 so partion-all steps over the last item effectively
;; dropping it!
#+end_src

** [[https://www.4clojure.com/problem/45][#45 Intro to Iterate]]
   What I thought iterate would output is ~(4 4 4 4 4)~, that is, just taking the function and making an infinite sequence out of it. What it actually outputs is ~(1 4 7 10 13)~ which is x, f(x), f(f(x), f(f(f(x))), etc. This very much looks like a versatile variation of ~reduce~ and I wonder if previous examples could be solved with it (for example #33 Replicate a sequence).
   A quick first attempt to see what iterate would look like gives me the impression that since iterate returns the first input as a result that this will either have to be stripped away, buuuut it does make me think of the fibonacci sequence where the initial values are a good candidate for the output
 #+begin_src clojure
 (take 5 (iterate #(+ 3 %) 1))
 ;; => (1 4 7 10 13)

 (+ 1 1);; => 2
 #+end_src

 #+begin_src clojure
   (take 2 (iterate #(repeat 4 %) [:a :b]))
   ;; => ([:a :b] ([:a :b] [:a :b] [:a :b] [:a :b]))

   ;; fib attempt
   (take 5 (iterate #(+ % %) 1))
   ;; => (1 2 4 8 16)
   ;; => (1 2 3 4 5)

   (#(take % (iterate (fn [[a b]] [b (+ a b)]) [1 1])) 8)
   ;; => ([1 1] [1 2] [2 3] [3 5] [5 8] [8 13] [13 21] [21 34])
   ;; => (1 1 2 3 5 8 13 21) after adding map first

   ;; first I don't think I understand the destructuring
   (let [[a b] [1 3]]
      (str a " " b))
   ;; => "1 3"
 #+end_src
     This keeps catching me out, when a vector is destructured to a vector the values are mapped to corresponding variable names so the above fib variation with iterate looks like return the vector that consists of the second input variable as the first result and the second result is the first input plus the second input, then feed that resulting vector into the same function so [1 1] -> [1 2] -> [2 3] -> [3 5] -> [5 8]
  I suppose the discover fiction might have gone like:
  1) first think about explaining exactly what the fib sequence is doing and pretend that there is a way to feed outputs of functions back to themselves iteratively.
  2) then somehow one has to know that the iterate function is exactly what fits that imagined patter (of course pure recursion is probably the simpler approach) but given that iterate does exist then map first through that generated sequence.
     For the discovery process to work it's important to think like feynman when he says It's ok not to know everything. Just move forward with the abstraction and take note of where you are stuck, the mind will create a kind of sieve that will make the solution pop out eventually!
** [[https://www.4clojure.com/problem/47][#47 Contain Yourself]]
   Using ~contains?~ on an indexed sequence takes the second argument to literally mean is index n in the sequence. However when used on a map or a map-like structure then ~contains?~ looks to see if the KEY is in the collection. Fun fact, I did not know until this exercise that a set is a map-like collection  but this makes sense to me in that a set can be thought of as a collection of keys, so key comparisons in ~contains~ returns true if key is in set.
** [[https://www.4clojure.com/problem/49][#49 Split a sequence]]
   Without using split-at, is a good clue to look at split-at but instead looking at the first params shows us that it's not an index to split at, instead it reads more like ~take~, as in ~take~ the first 3 and return the rest...like maybe ~cons~
#+begin_src clojure
(#(cons (take %1 %2) (vector (drop %1 %2))) 3 [1 2 3 4 5 6])
;; => ((1 2 3) (4 5 6))
(#(list (take %1 %2) (drop %1 %2)) 3 [1 2 3 4 5 6])
;; => ((1 2 3) (4 5 6))
((juxt take drop) 3 [1 2 3 4 5 6])
;; => [(1 2 3) (4 5 6)]
#+end_src
~juxt~ is especially interesting in that it takes left to right order and applies to the inputs so for something like juxt f(x) g(x), f is applied first to the inputs and then independently g is applied to the inputs and the results are returned as a tuple (f,g). This is related to comp however comp applies right to left (normal order) and pushes the inputs, in our above example this would look like applying function g and then pushing the results of function g into function f finally returning results.
** [[https://www.4clojure.com/problem/51][#51 Advanced Destructuring]]
   https://blog.brunobonacci.com/2014/11/16/clojure-complete-guide-to-destructuring/
** [[https://www.4clojure.com/problem/61][#61 Map Constructions]]
   Given two collections, make a map where the first coll are the keys and the second are the values without using ~zipmap~ : first thought ~map-indexed~ ... which is a weird first thought...
#+begin_src clojure
((fn [c1 c2]
   (map (fn [x] (assoc {}) ))) [:a :b :c] [1 2 3]);; => ()

(assoc {} :a 1)
;; => {:a 1}

(into [] [1] )
;; => [1]

(map (fn [x]
       (reduce
         (fn [acc y]
           (assoc acc x y))
         {}
         [1 2 3])
       )
     [:a :b :c])
;; => ({:a 3} {:b 3} {:c 3})

;; function map should accept coll-number-of-params! this makes sense now!
(map vector [1 2 3] [:a :b :c])
;; => ([1 :a] [2 :b] [3 :c])

(into (hash-map) [[1 :a] [2 :b] [3 :c]])
;; => {1 :a, 2 :b, 3 :c}

(map #(assoc {} %1 %2) [1 2 3] [:a :b :c])
;; => ({1 :a} {2 :b} {3 :c})

(into (hash-map) (map vector [1 2 3] [:a :b :c]))
;; => {1 :a, 2 :b, 3 :c}

(#(into (hash-map) (map vector %1 %2)) [:a :b :c] [1 2 3])
;; => {:a 1, :b 2, :c 3}
#+end_src
This was absolutely just about working in the REPL trying to build an intuition, I struggled with is and in some ways I'm not surprised as my familiarity with maps in clojure are not as strong as with vectors and lists...although I suspect that maps have some of the more unique features that clojure has to offer
Looking at other solutions:
#+begin_src clojure
;; using interleave, breaking it apart first
( #(interleave %1 %2) [:a :b :c] [1 2 3])
;; => (:a 1 :b 2 :c 3)
(apply hash-map '(:a 1 :b 2 :c 3));; => {:c 3, :b 2, :a 1}

;; i'm thinking that i just don't have a familiarity with hash-map
;; built up
(hash-map :a 1);; => {:a 1}
(apply hash-map [:a 1]) ;; => {:a 1}
(hash-map :a [:b 2])
;; => {:a [:b 2]}

;;so this is a very elegant solution
(#(apply hash-map (interleave %1 %2)) [:a :b :c] [1 2 3])
;; => {:c 3, :b 2, :a 1}

;;walking through the following since there is still some confusion about
;; how to effectively use map and reduce

((fn [k v] (assoc {} k v)) :a 1);; => {:a 1}

;;mapv is a map that returns a vector
(mapv (fn [k v] (assoc {} k v)) [:a :b :c] [1 2 3]);; => [{:a 1} {:b 2} {:c 3}]

;; and here is an example of reduce where the second value (a seq) is generated with
;; a map function...probably a common pattern
((fn [ks vs]
   (reduce conj {} (mapv (fn [k v] (assoc {} k v)) ks vs))) [:a :b :c] [1 2 3])
;; => {:a 1, :b 2, :c 3}
;; very cool and very fundamental usage where a sequence of values is almost
;; attached to the end of another function, which is reduce here ;)

;; a simpler version can be attached in the same place without using mapv
;; and perhaps using even simpler logic
(map (fn [k v] {k v}) [:a :b :c] [1 2 3]);; => ({:a 1} {:b 2} {:c 3})
;; this simpler form takes the key and value and places it into a map literal
;; instead of using assoc and mapv is not explicitly needed
(conj {} {:a 1});; => {:a 1}
;; however it is good to remind ourselves that reduce and map take a sequence
;; but they only evaluate it one time at a time, and so it is taken outside of
;; the sequence for evaluation (this is of course so obvious but noting it means
;; perhaps that I understand something is automatically given to us here -> almost
;; like a free ~apply~ if that makes sense)

;; we can take the exact seq generating function and use into instead of reduce
((fn [ks vs] (into {} (map (fn [k v] {k v}) ks vs))) [:a :b :c] [1 2 3]);; => {:a 1, :b 2, :c 3}
(into (into {} {:a 1}) {:b 2})
;; => {:a 1, :b 2}
;; into is still somewhat confusing to me so it's helpful to remember that it
;; uses conj to add the internal collection to the to-collection
;; in my mind conj seems like it is escaping the list or vector and applying
;; itself to the internals of the collection which is not what I'm used to
(conj () '(1 2 3))
;; => ((1 2 3))
;; however the differeGnce as saw above is that into uses reduce with conj
;; and internally into also uses reduce and conj together, this is why this is
;; confusing to me and now I see it! conj on it's own takes the entire collection
;; not just the internals and adds it to the to-collection!
;; anyhow a demonstration of this is below:
(into {} [{:a 1} {:b 2} {:c 3}])
;; => {:a 1, :b 2, :c 3}

;; merge is a useful function that literally combines two maps together, where
;; conflicting keys overwrite each other, the last key is the final result
(merge {:a 1} {:b 2} {:c 3})
;; => {:a 1, :b 2, :c 3}
;; so using reduce with the previous collection (list of maps or vector of maps)
;; will pluck the first two and then the final map and place it into a single map
;; very handy!
((fn [ks vs] (reduce merge (map (fn [k v] {k v}) ks vs))) [:a :b :c] [1 2 3]);; => {:a 1, :b 2, :c 3}
#+end_src

** [[https://www.4clojure.com/problem/66][#66 GCD]]

** [[https://www.4clojure.com/problem/83][#83 A half truth]]
   Function should return true if some but not all of the params are true, all false is false, all true is false, some true is true, sounds like I should investigate ~and~ : and looks stops on false and returns that value, if and makes it to the end it returns the final value. Or stops on true evaluations and returns the value or makes it to the end and returns the last value.
   More succinctly put, and continues with true, or continues with false
#+begin_src clojure
;; various forms of and applied to sequence
(and true false nil)
;; => false
;; => nil
;; => false
;; => 4

;; still having trouble applying and to a collection
((fn [& d] (and false true false)) false true false)
;; => false

;; here is just my logic templated out short circuiting that problem of applying
;; and to a collection
((fn [& c] (and (= (and false true false) false) (= (or false true false) true))) false true false)
;; => true
;; => false
;; => false
#+end_src
So it turns out that using ~apply~ with ~and~ or any other macro is a big fail, I have marked this particular issue as something to figure out once I am more knowledgeable about how to write a macro and what is specifically happening but it is good to note this behaviour for now.
However there may be more luck using ~every~ and ~not-every
#+begin_src clojure
(every? identity '(false true false))
;; => false
(not-every? true? '(false true false))
;; => true
(every? identity '(false false false))
;; => false
(every? identity '(true true true))
;; => true
((fn [& c] (and (not-every? false? c) (not-every? true? c))) true  false true)
;; => true

;; this is almost an english sentence in terms of how clear it is

#+end_src
Some of the difficulties that I had were that I had to remember how to take multiple individual inputs and scoop them up into a collection. This is what the [& c] is for, however I had never seen that without a first variable such as [a & c] so I did not know that the &c would be the entire sequence if there was no preceding variables, great to note! The rest of my difficulty was that I did not know that you cannot ~apply~ a macro and ~and~ and ~or~ are macros, so I ditched those macros and used not-every? which turned out to read more clearly to me. One solution I found as simple as mine but using slightly different funcs:
#+begin_src clojure
((fn [& xs]
   (true? (and (some true? xs) (some false? xs)))) true false true)
;; => true
;; this is equivalent to what I used with not-every? however it's arguably
;; even more readable as some true some false shoulder shrug? almost like
;; and idiom or like comme ci comme ca in french
((fn [& xs]
   (and (some true? xs) (some false? xs))) false false)
;; => nil
;; => nil
;; thinking to try to remove the first true? reveals that all true or false
;; returns nil
(some true? '(false false));; => nil
;; which is exactly how some works so in this particular case I believe my answer
;; with not-every? is even more clear than this example and shorter without them
;; extra true? evaluation -- party!
#+end_src

* SICMutils
