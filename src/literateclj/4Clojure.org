* 4Clojure Problems
** [[https://www.4clojure.com/problem/21][#21 Nth from seq]]
   My first attempt is a non-functional approach but hey, non-functional thinking that gets to a solution is valid right?
#+begin_src clojure
((fn [coll idx]
   (loop [remain coll
          i      0]
     (if (or (nil? remain) (= idx i)) ; checks to see if seq over, party!
       (first remain)
       (let [[_ & r] remain] ; using destructuring to take rest of remain
         (recur r (inc i)))))) '(4 5 6 7) 2)
;; => 6
(rest '(4 5 6 7))
;; => (5 6 7)
;; so an easy win here is similar but using rest
((fn [coll idx]
   (loop [remain coll
          i      0]
     (if (or (nil? remain) (= idx i)) ; checks to see if seq over, party!
       (first remain)
       (recur (rest remain) (inc i))))) '(4 5 6 7) 2)
;; => 6
;; this at least gets rid of the extra let form
;; a more clever version is
(#(last (take (inc %2) %1)) '(4 5 6 7) 2)
;; => 6
(drop 1 [1 2 3 4]);; => (2 3 4)
;; drop drops from the front, nice
(#(first (drop %2 %1)) '(4 5 6 7) 2)
;; => 6
#+end_src
** [[https://www.4clojure.com/problem/22][#22 Count a sequence]]
   Why not try another loop?
#+begin_src clojure
(#(loop [coll %
         i    0]
    (if (empty? coll)
      i
      (recur (rest coll) (inc i)))) '(1 2 3 3 1))
;; => 5
#+end_src
Some of the solutions seemed pretty advanced to me even after coming back, let's take a look:
#+begin_src clojure
;; using reduce with constantly
(constantly 1)
;; => #function[clojure.core/constantly/fn--5690]
;; huh, this is now a function that takes any number of args and returns 1
((constantly 1) 100 2 3);; => 1
;; a really fascinating way to count a seq is with mapping this function
;; across all values of the sequence and reduce + to accumulate the final value
(reduce + (map (constantly 1) [1 2 3 3 1]));; => 5

;; only incrementing the accumulator in reduce is quite creative!
(#(reduce (fn [a b] (inc a)) 0 %) '(1 2 3 3 1))
;; => 5
#+end_src
** [[https://www.4clojure.com/problem/23][#23 Reverse a sequence]]
   Without using ~reverse~ or ~rseq~ I remember a trick using ~conj~ on a list is supposed to reverse it since lists add at the head and ~into~ uses ~conj~ behind the scenes
#+begin_src clojure
(#(into () %) [1 2 3 4 5])
;; => (5 4 3 2 1)
#+end_src
I think I'm pretty clever here...ha, let's look at some other solutions
#+begin_src clojure
;; reduce conj is another way of saying into
(#(reduce conj () %) [1 2 3 4 5])
;; => (5 4 3 2 1)

;; this is interesting and not immediately obvious to me
(#(reduce
    (fn [rs ls] (cons ls rs)) [] %) [1 2 3 4 5])
;; => (5 4 3 2 1)
(cons 1 []);; => (1)
(cons 2 '(1));; => (2 1)
(cons 3 '(2 1));; => (3 2 1)
;; ok cool, this is the reverse of my method but the same logic of
;; adding a number to the head of a list (reverse as in reverse order
;; this is number first then list my solution is list first then number)
#+end_src
** [[https://www.4clojure.com/problem/25][#25 Return only odd numbers]]
  First attempt and realized that != is not= in clojure
#+begin_src clojure
((fn [s] filter #(not= 0 (mod % 2)) s) '(1 3 5))
;; => (1 3 5)
#+end_src
The code golf and probably the clojure way is:
#+begin_src clojure
(#(filter odd? %) '(1 3 5))
;; => (1 3 5)
#+end_src
** [[https://www.4clojure.com/problem/26][#26 Fibonacci Sequence]]
   Write a function that returns the X numbers in the Fibonacci sequences.

   The Fibonacci sequence is like the hello world of recursion, and for me it's both a difficult and fascinating problem. Not gonna lie this took me a while and to be honest I'm going to have to look at this a few more times for it to really start to feel natural, but writing this in clojure is perhaps the most intuitive, the following are a number of explorations and even this is not inclusive of everything I tried!
#+begin_src clojure
;; most of the time fib sequences are given 1 1 as the start
;; my first thought is to understand how the fib seq is constructed
;; starting with the values 1 1 we add the two together and add the result
;; to the sequence (1 1 2), repeating once more we take the last items from the
;; list and add the result to the list (1 1 2 3) and so on, seems like a ~cons~
;; style recursion with a take-last add comp, but it looks like comp takes many
;; arguments and I still keep being caught out by the difference between many
;; args and a single collection of args!

;; instead let's see if this chunk can be recursed
(apply + (take-last 2 '(1 2 3)))
;; => 5

;; just writing this down because it seems to be a point of confusion still
;; into is for working from collection to collection

(into [1 1] [3])
;; => [1 1 3]
(into [1 1] [[3] [1]])
;; => [1 1 [3] [1]]

;; cons and conj are for building collections
;; cons takes whatever is in the first arg and puts it into the second arg which
;; must be a collection, and cons adds to the beginning

(cons 1 [1 2 3])
;; => (1 1 2 3)
(cons [1] [1 2 3])
;; => ([1] 1 2 3)

;; conj takes a collection and adds whatever follows to the collection, if the
;; collection is a list it adds to the beginning and if it is a vector it adds
;; it to the end, so the type of collection matters for placement

(conj [1] 1)
;; => [1 1]
(conj [1] [1])
;; => [1 [1]]

;; into and conj have the to-collection on the left, cons is the outlier since
;; it's to-colleciton is the second argument. This also means that cons can only
;; take 2 arguments while into and conj take unlimited args.
;; Both cons and conj add entire collections to the sequence preserving the
;; colleciton (see second example on both) where as into takes the inner
;; collection, so when trying to add a collection of collections to a collection
;; then a collection is added, if only trying to add a collection to another
;; collection then the contents of the collection are added...see into examples.
;; I hope this clears this up, I'm not sure why I'm not able to keep these
;; straight but perhaps it's because I see them as so closely related to each
;; other...and they are in that the results are always collections, the devil is
;; as usual in the details

((fn fib
   [coll n]
   (conj coll (apply + (take-last 2 coll)))) [1 1] 3)
;; => [1 1 2]

;; the above structure reminds me of something that might be reducible
(reduce (fn [f s] (conj [] f s (+ f s))) [1 1])
;; => [1 1 2]

(reductions (fn [f s] (conj f (apply + (take-last 2 f)))) [1 1] (range 5))
;; => ([1 1] [1 1 2] [1 1 2 3] [1 1 2 3 5] [1 1 2 3 5 8] [1 1 2 3 5 8 13])
;; => ([1 1] [1 1 2] [1 1 2 4] [1 1 2 4 8] [1 1 2 4 8 16] [1 1 2 4 8 16 32])
;; => [1 1 2 4 8 16 32]

;; brilliant! and it only took me 12 days! learned about using ~reductions~ to
;; see the intermediate steps and also about debugging in cider by setting a
;; breakpoint with , d b and stepping through the evaluation, super handy and
;; worth the extra time spent. Also of note, took a break to run and shower
;; had lunch while looking over the problem and boom, answer. Note to self:
;; it is ok and often beneficial to step away for a moment (not the first time
;; I've had to remind myself of this miraculous life-hack)

;; final answer for 4clojure's purposes
(#(reduce (fn [f s] (conj f (apply + (take-last 2 f)))) [1 1] (range (- % 2))) 5)
;; => [1 1 2 3 5]

(#(reduce (fn [f s] (conj f (apply + (drop s f)))) [1 1] (range (- % 2))) 5)
;; => [1 1 2 3 5]

(#(reduce (fn [f s] (conj f (apply + (drop s f)))) [1 1] (range (- % 2))) 7)
;; => [1 1 2 3 5 8 13]

;; as an added bonus the above also takes care of the more generalized version
;; of the fibonacci seq if the starting vector is given as [0 1]

;; I have to admit this is the second time that I've come across this fib problem
;; in 4clojure and I thought I would try to refresh my memory by approaching it
;; again with my slightly more mature knowledge of the core library my first
;; solution is as follows:

((fn [n]
   (loop [m [1 1]]
     (if (>= (count m) n)
       m
       (recur (conj m (+ (last m) (last (butlast m)))))))) 5)
;; => [1 1 2 3 5]

;; which looks like almost exactly the same internal logic of somehow
;; add the starting vector to a collection and then take the last and the
;; second last add them and then conj into the rolling collection.

;; Here we see that I have put a block to essentially return the starting vector
;; if n is less than 3 but then I return the starting vector, which is wrong for
;; n 0,1,2. My solution only works for n > 3, so instead I can add take n as
;; follows

((fn [n]
   (loop [m [1 1]]
     (if (>= (count m) n)
       (take n m)
       (recur (conj m (+ (last m) (last (butlast m)))))))) 3)
;; => (1 1 2) n = 3
;; => (1 1)   n = 2
;; => (1)     n = 1
;; => ()      n = 0

;; probably my favorite solution:
(#(take % ((fn fib [f s] (lazy-seq (cons f (fib s (+ s f))))) 1 1)) 5)
;; => (1 1 2 3 5)
;; which looks like:
;; fib [1 1] | fib [1 2] | fib [2 3] | fib [3 5] | fib [5 8] |
;;  (cons 1     (cons 1     (cons 2     (cons 4      (cons 5 (empty) )))))
;; which recursively reduces down as below: read right to left
;; (1 1 2 3 5)  (1 3 4 5)   (2 3 5)     (3 5)        (5)
;;
;; the ~lazy-seq~ part still feels like magic but I know engough about it
;; to know that it's used with something like ~take~

;; the final solution that I'll look at here is one with ~iterate~
;; iterate is an important function that again produces a lazy seq
;; given a function and it's arguments
;; (x,f(x),f(f(x)),f(f(f(x))),f(f(f(f(x))))...etc)
;; what's nice about the fib seq is that it's logic is simple
(fn [[x1 x2]] [x2 (+ x1 x2)])
;; which very simply translates to given two arguments, return a vector
;; containing the second arg first and the summation of both args as the
;; second index. Putting this into iterate gives us:
(take 5 (iterate (fn [[x1 x2]] [x2 (+ x1 x2)]) [1 1]))
;; => ([1 1] [1 2] [2 3] [3 5] [5 8])
;; which gives us a sequence where if we squint we can see the fib in
;; the first index of each vector, to extract that we map
(map first (take 5 (iterate (fn [[x1 x2]] [x2 (+ x1 x2)]) [1 1])))
;; => (1 1 2 3 5)
#+end_src
And honestly, that's all I can take for the fibonacci sequence. While it is a fascinating problem it also is something that would help if I threw some of the key concepts into a space repetition deck, revisiting more than a few more times will certainly allow for more familiarity.
** [[https://www.4clojure.com/problem/27][#27 Palindrome Detector]]
   I feel like my answer is cheating since I'm only checking if the first and last items match, but it passes!
#+begin_src clojure
(#(let [v %]
    (= (first v) (last v))) '(1 1 1 3 3 1 1 1))
;; => true
#+end_src
So here are the honest solutions
#+begin_src clojure
;; this first solution uses reverse which is probably a great function to know about
(#(= (seq %) (reverse (seq %))) "racecar")
;; => true
;; here seq is used to force a string into a collection, otherwise
;; "racecar" ->  '(\r \a \c \e \c \a \r)
#+end_src
:
** [[https://www.4clojure.com/problem/28][#28 Flatten a Sequence]]
   Without using flatten...the first time around this problem gave me hell:
#+begin_src clojure
;; I'm thinking of using cond with recursion built in to each condition.
;; Is there also a way to use apply here though?

(apply conj [] '(:a))
;; => [:a]
(apply apply conj [] '((:a)))
;; => [:a]
(apply apply apply conj [] '(((:a))))
;; => [:a]

;; how do we get the depth of a value?
(nth (nth '((:a)) 0) 0)
;; => :a

;; gotta say this problem still got me again, though this time I was most of the
;; way there. With a problem like this using cond I really have to understand how
;; the recursion finishes! For this  case when x is nil then the missing piece for
;; me was to return an empty list () which would complete the final recursion
;; ok at least I have a sense of where the logic broke down, that's at least
;; something
((fn fltn [[x & xs]]
   (cond
     (seq? x) (fltn x)
     (nil? x) ()
     :else    (cons x (fltn xs))
     ))
 '((((:a)))))
;; => (:a)

;; I remember this similar answer that probably subconsciously inspired me together
;; to the above cond/recur:
(fn fltn2 [[h & t]]                           ; 1)
  (cond
    (nil? h)        ()                           ; 2)
    (sequential? h) (concat (fltn2 h) (fltn2 t)) ; 3)
    :else           (cons h (fltn2 t)))) ; 4)

;; 1) so here destructuring is like a free reverse cons
;; 2) here is the crucial finishing step where an empty list is inserted into the
;; :else con
;; 3) while we still have nested collections we recurse over both the head and tail
;; of the remaining sequence
;; 4) finally, the :else is a kind of default condition that evaluates to true
;; for any conditions that do not match the previous, ending with cons allows the
;; nil condition to insert an empty list and signals the end of the recursion
#+end_src
I did not find this problem to be "easy" although it is in the easy section. Let's take a look at a few more solutions that could be helpful:
#+begin_src clojure
;; mapcat sounds like it might be useful to us
((fn fltn2 [coll]
   (mapcat #(if (sequential? %)
              (fltn2 %)
              [%])
           coll))
 '((1 2) 3 [4 [5 6]]))
;; => (1 2 3 4 5 6)

;; really interesting solution, the if statement provides a branch point
;; for either recursion or wrapping in a vector since concat needs a collection
;; in any of it's arguments

;; (mapcat (mapcat [1] [2]) (mapcat [3] (mapcat [4] (mapcat [5] [6]))))
;; then
(concat (concat [1] [2] (concat [3] (concat [4] (concat [5] [6])))))
;; => (1 2 3 4 5 6)

;; another variation of this theme only mapcat's the nested sequences and
;; wraps all others in a vector:
((fn fltn3 [coll]
   (if (coll? coll)
     (mapcat fltn3 coll)
     [coll]))
 ;; => ((1 2 (3)) 4)
 '((((:a)))) )
;; => (:a)

;; same idea fewer calls to mapcat

;; the last solution I will review for now is one involving tree-seq which of
;; course is interesting because I had to look it up. This is mostly all from
;; clojuredocs.org/tree-seq

(tree-seq next rest '(:A (:B (:D) (:E)) (:C (:F))))
;; => (
;; (:A (:B (:D) (:E)) (:C (:F)))
;; (:B (:D) (:E))
;; (:D)
;; (:E)
;; (:C (:F))
;; (:F)
;; )

;; Each node is a number or a seq,
;; so branch?==seq? and children==identity
;;
;;     .
;;    / \
;;   .   .
;;  /|\  |
;; 1 2 . 4
;;     |
;;     3
;;
;; ... each sub-tree is serialized in depth-first order

(tree-seq seq? identity '(1 2 (3 (4))))
;; => ((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4)
(tree-seq seq? seq '(1 2 (3 (4))))
;; => ((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4)
(tree-seq sequential? seq '(1 2 (3 (4))))
;; => ((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4)

(tree-seq odd? seq '(1 2 (3 (4))))
;; This processing ...
;; (sequential? '(1 2 (3 (4)))) ;; returns true ... -> (1 2 (3 (4))) <--- !!!
;; (sequential? 1)              ;; returns false ... -> 1
;; (sequential? 2)              ;; returns false ... -> 2
;; (sequential? '(3 (4))        ;; returns true  ... -> (3 (4))     <--- !!!
;; (sequential? 3)              ;; returns false ... -> 3
;; (sequential? '(4))           ;; returns true  ... -> (4)         <--- !!!
;; (sequential? 4)              ;; return false  ... -> 4

(sequential? '(1 2 (3 (4))));; => true
(seq  '(1 2 (3 (4))));; => (1 2 (3 (4)))

;; ok so here is the solution in question:
(#(filter (complement sequential?)
          (rest (tree-seq sequential? seq %))) '((1 2) 3 [4 [5 6]]))
;; => (1 2 3 4 5 6)

;; let's try to break it down. first we know that the inner tree-seq
;; portion is going to walk the nodes of the tree and give us a
;; collection of those nodes.

(tree-seq sequential? seq '((1 2) 3 [4 [5 6]]))
;; => (((1 2) 3 [4 [5 6]]) (1 2) 1 2 3 [4 [5 6]] 4 [5 6] 5 6)
;; => (
;; ((1 2) 3 [4 [5 6]])
;; (1 2)
;; 1
;; 2
;; 3
;; [4 [5 6]]
;; 4
;; [5 6]
;; 5
;; 6
;; )

;; what does rest do?
(rest '((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4));; => (1 2 (3 (4)) 3 (4) 4)
;; rest escapes one layer of nested collection, which I'm not sure we need

(#(filter (complement sequential?)
          (tree-seq sequential? seq %)) '((1 2) 3 [4 [5 6]]))
;; => (1 2 3 4 5 6)

;; just as I suspected, the filter "not"-sequential? scoops up all the leaf
;; nodes and drops all the collection nodes, brilliant!

(filter (complement sequential?)
        '(((1 2) 3 [4 [5 6]]) (1 2) 1 2 3 [4 [5 6]] 4 [5 6] 5 6))
;; => (1 2 3 4 5 6)

;; tree-seq is clearly very powerful and along the way I've learned about
;; next and rest
#+end_src

** [[https://www.4clojure.com/problem/29][#29 Get the caps]]
   See string, think regex
#+begin_src clojure
(#(clojure.string/replace % #"[^A-Z]" "") "HeLlO, WoRlD!")
;; => "HLOWRD"
#+end_src
 However it looks like other solutions unanimously used ~re-seq~
#+begin_src clojure
(#(apply str (re-seq #"[A-Z]+" %)) "$#A(*&987Zf")
;; => "AZ"
#+end_src
** [[https://www.4clojure.com/problem/30][#30 Compress a Sequence]]
   The trick here is to notice that the function must remove consecutive duplicates and not duplicates, which of course would simply be solved by making a set out of the collection. I think ~reduce~ may do the trick here
#+begin_src clojure
(#(reduce (fn [acc x] (if (not= (last acc) x)
                        (conj acc x)
                        acc)) [] %) [1 1 2 3 3 2 2 3])

;; this is embarrassing to admit but better now than never: I think I just
;; understood how reduce works. I have used reduce in other languages and
;; it is something that I've had to develop a sort of black box intuition
;; about but now I see that the first arg (usually called acc for accumulator)
;; is the result of calling f on the previous two args, the docs explain this
;; as clear as day to me now and it's no longer surprising that the result looks
;; like we're building up a function that looks like this in a lisp form
;; (f(f(f(f(f(a0,a1),a2),a3),a4),a5),a6) and so on! This is the best kind of
;; forehead slap moment!

;; when I first encountered this problem I was still very much thinking about
;; loops, and this was my somewhat hacked together solution:
((fn
   [coll]
   (loop [c      coll
          result []]
     (if (empty? c)
       result
       (let [nr (if (not= (first c) (last result))
                  (conj result (first c))
                  result)]
         (recur (rest c) nr))))) [1 1 2 3 3 2 2 3]);; => [1 2 3 2 3]
#+end_src
There's only one other solution which I think should be the goto answer:
#+begin_src clojure
(#(map first (partition-by identity %)) [1 1 2 3 3 2 2 3])
;; => (1 2 3 2 3)

;; I find this so so clever, partition uses an fn to select groups, if the fn
;; returns the same answer then that value is grouped together, thereby
;; using identity groups by well...the identity of the thing. Then once
;; those groups are formed map first selects one from each group!
#+end_src
I should mention that I was so incredibly lost the first time that I attempted this problem and this well written blog post really helped me out: [[https://medium.com/@daniel.oliver.king/getting-work-done-in-clojure-the-building-blocks-39ad82796926][Getting Work Done In Clojure]]
** [[https://www.4clojure.com/problem/31][#31 Pack a Sequence]]
   Pack consecutive duplicates into sub-lists
This was so simple since I've had some experience with partition-by in the past. It's a good example of when the ~identity~ function is valuable (hard to imagine when just coming across it for the first time!)
#+begin_src clojure
(partition-by identity [1 1 2 1 1 1 3 3])
#+end_src
** [[https://www.4clojure.com/problem/32][#32 Duplicate a sequence]]
   Double each item in a collection:
#+begin_src clojure
(#(sort (concat % %)) [1 2 3])
;; => (1 2 3 1 2 3) -> pre sort
;; => (1 1 2 2 3 3)
#+end_src
For some reason I don't like using sort like this, probably a sign that there's a simpler way. Luckily there are some interesting alternative answers out there:
#+begin_src clojure
;; I love seeing reduce used to build a sequence since much of the time
;; I see the opposite
(#(reduce (fn [acc x] (conj acc x x)) [] %) [1 2 3])
;; => [1 1 2 2 3 3]
;; reduce is just so clear here. see x twice, add x twice, nothing tricky

;; ~using interleave~ however is a bit short and tricky to me
(#(interleave % %) [1 2 3]);; => (1 1 2 2 3 3)
;; but it's saying the same thing, it's just that interleave is not the first
;; function I think of to use on itself, clever!

;; where there is a reduce there is surely a ~map~
(#(mapcat (fn [x] [x x]) %) [1 2 3])
;; => (1 1 2 2 3 3)
;; it's nice to note that this could have been a flatten map situation
;; so when flatten and map are together I think of mapcat instead

;; and finally just because I think the ~list~ function is overlooked
(mapcat #(list % %) [1 2 3])
;; => (1 1 2 2 3 3)
#+end_src

** [[https://www.4clojure.com/problem/33][#33 Replicate a Sequence]]
   This initially made me think about the ~dotimes~ function however ~do times~ takes an n variable and ranges from 0 to n. Instead I used ~repeat~ to and ~take~ to build a basic understanding of the problem.
#+begin_src clojure :results silent
  (flatten (take 4 (repeat 4 [:a])))
  ;; => (:a :a :a :a)
#+end_src
    One approach could be to map across the entire sequence.
#+begin_src clojure
  ((fn [coll n]
    (flatten (map (fn [x] (take n (repeat n x))) coll))) [:a :b] 4)
  ;; => (:a :a :a :a :b :b :b :b)
#+end_src
   However it should also be possible to use ~reduce~ and perhaps drop the ~flatten~ function.
#+begin_src clojure
  ((fn [coll n]
    (reduce (fn [f s]
              (apply conj f (take n (repeat n s))))
            []
            coll)) [:a :b] 4)
  ;; => [:a :a :a :a :b :b :b :b]
#+end_src
   The brilliant apply step shown above is referenced from a [[https://github.com/morrxy/4clojure/blob/master/problem/33.Replicate%20a%20Sequence.clj][solution]] online and here it is helpful to see apply as a way to push conj into the the following sequence, e.g. without the apply the output is ~[(:a :a :a :a) (:b :b :b :b)]~, and apply can be seen as applying conj to the inner parens ~(conj :a :a :a :a)~ rather than ~(conj (:a :a :a :a))~
   In the same link above is the solution ~(fn [s n] (mapcat (partial repeat n) s))~ highlights a really perfect use of ~partial~ (functional thinking in action!) and introduces me to ~mapcat~. I now wonder if I can apply the ~partial~ function to more of my solutions as a way of practicing a kind of encapsulation without writing separate helper functions (a kind of internal encapsulation).

** [[https://www.4clojure.com/problem/34][#34 Implement Range]]
   Without using range of course, my first thought of course is a loop based solution but now that this is my second time attempting this let's see what I've learned:
#+begin_src clojure
;; here is my first naive approach, I'm surprised that it's a recursive
;; solution!
((fn cnt
   [start finish]
   (let [r (- finish start)]
     (if (> r 0)
       (cons start (cnt (inc start) finish))))) 1 4)
;; => (1 2 3)

;; one thing that I think is worth mentioning since I am seeing a lot of
;; solutions to this problem online that use recursive/cons approach but
;; also add an empty [] as an arg, the recursive cons approach works
;; because on it's last iteration it produces an empty () where them
;; call to recurse should be. This allows the second to last (or first from
;; an execution perspective) cons to add it's first argument to an empty list!
;; so the empty [] is not normally needed and adding it is a sign perhaps that
;; the detail of "how does recursion stop and what does that look like" is not
;; yet fully understood by the participant
#+end_src
Other solutions that I found interesting:
#+begin_src clojure
(#(take (- %2 %1) (iterate inc %1)) 1 4)
;; => (1 2 3)

;; I really like this solution, probably the clearest use of iterate which is
;; a function that I'm trying to wrap my head around how to use more often

;; here is a very clear loop/recur version.
;; It's funny to me that I say this
;; is clear since the work is being done by (conj acc start) which is buried
;; at the bottom of the function and everything else is there to support
;; the concept of immutable variables, also overwriting a local variable with
;; the same name is not clear either
((fn [start end]
   (loop [start start
          acc   []]
     (if (>= start end)
       acc
       (recur (inc start) (conj acc start))))) 1 4)
;; => [1 2 3]
;; It's funny to me that I say this
;; is clear since the work is being done by (conj acc start) which is buried
;; at the bottom of the function and everything else is there to support
;; the concept of immutable variables, also overwriting a local variable with
;; the same name is not clear either so maybe what I mean is that the language often;; loop/recur is still mostly how I think, it's less cognitive load to read.


#+end_src

** [[https://www.4clojure.com/problem/38][#38 Maximum Value]]
   Write a function that takes a variable number of arguments and return the maximum value. This was a rare moment where I believe the shortest answer just came to me:
#+begin_src clojure
(#(last (sort %&)) 1 8 3 4)
;; => 8
#+end_src
The symbol %& is so elegant here because it scoops up all the individual elements and wraps them in a tidy collection, I'm sorta surprised that I haven't tried using this in other places but now on my second pass I'll see if that can happen. One other solution that uses ~reduce~ really expresses the logic of finding the max quite clearly:
#+begin_src clojure
(#(reduce (fn [f s] (if (> f s) f s)) %&) 1 8 3 4)
;; => 8
#+end_src
While the first solution is shorter, I prefer the legibility of this last function, it really shows that reduce as a sieve that can scoop up and take certain values, plus bonus on using %& again!
** [[https://www.4clojure.com/problem/39][#39 Interleave 2 Sequences]]
   My first gut solution to this (after seeing it again) is:
#+begin_src clojure
#(mapcat list %1 %2)

;; it is such relief that this just pops out after reviewing as I've been
;; doing, and really verifies to me that this process is beneficial to my
;; understanding of both functional programming and clojure as well, yay!

;; my first naive solution was not as clear but does show my loop based mental
;; model of such a problem (loops solve everything right?!)
((fn [c1 c2]
   (loop [[x    & xs]      c1
          [y         & ys] c2
          result           []]
     (if (or (nil? x) (nil? y))
       result
       (recur xs ys (conj result x y))))) [:a :b :c] [1 2 3])
;; => [:a 1 :b 2 :c 3]
;; absolutely nothing wrong with this, it's simple and legible but also
;; less succinct, it's almost like the difference between this answer and them
;; first is like the first is kind of like slang, we are demonstrating a
;; comfort with many of the more complex inner workings of the functional
;; programming dialect in discreet chunks where as the loop solution is a
;; meticulous piece by piece ordeal which doesn't flow in "spoken clojure"
;; if that makes any sense...because of the energy saved from a conversational
;; point of view we might take that energy to progress further, hmmm.

;; another quick solution because it expresses a common pattern
#(flatten (map list %1 %2))
;; this is just another example of seeing flatten outside of a map just means
;; mapcat
#+end_src
Two more solutions that I'd like to explore:
#+begin_src clojure
;; here is another recursive solution that is very clear
((fn l [a b & r]
   (if (or (nil? (first a)) (nil? (first b)))
     (flatten r)
     (l (rest a) (rest b) (conj (vec r) (first a) (first b))))) [:a :b :c] [1 2 3])
;; => (:a 1 :b 2 :c 3)
;; I am starting to build an intuition that when using conj in a recursive way
;; I often see that an extra variable is carried along to accumulate the results
;; this seems analogous to the loop solution I presented above
;; I also think that the ~vec~ function is very powerful since it can make a
;; an empty collection from nil e.g. (vec nil) is [] also (vec [1 2 3]) is just
;; [1 2 3] so it does not take an existing vector and wrap it into a nested vector
;; It is also interesting in this case that the destructuring lists &r here which
;; already makes whatever is left into a collection, but in this case it is
;; required because it makes the 3rd argument optional and so the recursive
;; function can use it when it calls itself...I do very much doubt that this
;; sort of pattern is a generally acceptable pattern for a function that is
;; exposed as a part of a public api as it exposes some of the internals of the
;; function to a perhaps unsuspecting developer...style guide?

;; the final solution I wish to investigate is the following:
((fn [& xs]
   (let [n (->> xs (map #(count %)) (apply min))]
     (reduce (fn [acc x] (concat acc (map #(nth % x) xs)))
             [] (range n))))
 [:a :b :c] [1 2 3])
;; => (:a 1 :b 2 :c 3)
;; my interest here is the introduction of the thread-last operator ->>
;; which takes the arg that follows it and applies it as the last argument
;; of whatever function pipeline follows it, but first let's explore how two
;; vectors are scooped up in the &xs destructuring

((fn [& xs] (str xs)) [:a :b :c] [1 2 3])
;; => "([:a :b :c] [1 2 3])"
;; just as suspected but good to see
;; so given a seq of two vectors lets see what ->> works

(let [n (->> '([:a :b :c] [1 2 3])
             (map #(count %))
             (apply min))]
  n)
;; => 3

;; a lot is going on here! first the map form is our first transducer in
;; the wild, and the clojure docs describe transducers as:
;; composable algorithmic transformations that are independent of context
;; as they specify the essence of the transformation in terms of an individual
;; element. Nice! (like a stream transformer in other languages -- sounds
;; "reactive" as well)

;; so the thread-last operator sets us up to use a pipeline and our first
;; part of that pipeline is a map form transducer
(map #(count %) '([:a :b :c] [1 2 3]))
;; => (3 3)

;; ah ok, so after the apply min step n is trying to give us the shortest of the
;; two collections, I imagine that if one longer and one shorter collection
;; are given, the longer collection is simply truncated, that's clear now!

;; finally we reduce
(reduce (fn [acc x] (concat acc (map #(nth % x) '([:a :b :c] [1 2 3]) )))
        [] (range 3))
;; => (:a 1 :b 2 :c 3)

;; so for every index created by range from (0 1 2) we map over each collection
;; (not limited to two can be any number) and we use concat to take index 0 for
;; example of both collections into one collection. This is in some ways very
;; advanced because of the steps taken to get to the solution, however once
;; broken apart into simpler portions the power of this kind of thinking almost
;; leaves a kind of discovery fiction of bread crumbs that one can imagine
;; e.g. the possibility of deducing the thought process taken to get to the
;; final answer is available in the individual chunks of the code, like
;; thought-legos!
#+end_src
** [[https://www.4clojure.com/problem/40][#40 Interpose a Sequence]]
   Without the function interpose, here is my first attempt. Still some effort involved to remember that any time I see a function applied to each index in a seq then the first thought should be map. This seems like there could be a more elegant solution, in particular I'm not fond of the ~flatten~ seems like there could be a simpler answer
#+begin_src clojure
((fn [v coll]
   (flatten (map (fn [x] (conj [] x v)) coll)) ) :z [:a :b :c :d])
;; => (:a :z :b :z :c :z :d :z)
#+end_src
 ...on closer inspection it seems like I got this one wrong, the last term should not be added, so the problem is to add something within the range of the collection...hmmm
#+begin_src clojure
((fn [v coll]
   (butlast (flatten (map (fn [x] (conj [] x v)) coll)))) 0 [1 2 3])
;; => (1 0 2 0 3)
#+end_src
...so now I am definitely suspicious that this is not as elegant as is possible so lets look at some other solutions to learn from them. Looks like I'm not alone in my approach but two other approaches interest me in that they introduce ~interleave~ and also use ~reduce~ (which is also seems like a pattern, anything map can do reduce can do better!). Looking at reduce first:
#+begin_src clojure
;; reduce here is using an accumulator which is a common pattern
;; lets start with the naive implementation
(reduce (fn [acc x] (conj acc x 0))
        []
        [1 2 3])
;; => [1 0 2 0 3 0]
;; so we can get rid of the flatten with reduce however
;; it does look like we're stuck with either droplast or butlast
;; Other solutions show us how to drop the flatten with mapcat
(mapcat (fn [x] (list x 0)) [1 2 3]);; => (1 0 2 0 3 0)
;; this is a good example of getting rid of flatten and still
;; keeping the simplicity of map but also it's nice to note that
;; the list function is a very simple way to make two things that
;; are not a collection into a list collection, this should be the
;; goto instead of fidgeting around with cons, conj, and into...
;; finally let's look at interleave
(#(interleave % (repeat 0)) [1 2 3])
;; => (1 0 2 0 3 0)
;; I really like this solution because the concept of using
;; repeat as a generative collection that simply produces a result as
;; they are needed seems succinct and powerful. It's also a way of thinking
;; that is foreign to me and so using it and seeing it really helps imagine
;; concrete use cases (or rather I believe it will make me more likely to apply
;; it in the future!)
#+end_src

** [[https://www.4clojure.com/problem/41][#41 Drop Every Nth Item]]
   Given coll and N drop ever N from coll
#+begin_src clojure
(def coll [1 2 3 4 5 6 7 8])
(partition 3 coll)
;; => ((1 2 3) (4 5 6))
;; oops this drops the last group if it is smaller than 3!
(partition-all 3 coll);; => ((1 2 3) (4 5 6) (7 8))
;; partition-all gives us the remaining partition even if it's size is too
;; small but we need to uniformly apply butlast to all so we need to pad instead
;; partition takes a n items, a step size which usually defaults to n, a padding
;; which here we use the vector of zero arbitrarily and the collection! perfect!
(partition 3 3 [0] coll)
;; => ((1 2 3) (4 5 6) (7 8 0))
((fn [c n]
   (mapcat butlast (partition n n [0] c))) coll 3);; => (1 2 4 5 7 8)
;; I bet there is a way to use reduce
((fn [c n]
   (reduce (fn [acc x] (apply conj acc (butlast x)))
           []
           (partition n n [0] c))) coll 3)
;; => [(1 2) (4 5) (7 8)] <-- solution before adding apply
;; => [1 2 4 5 7 8]
;; this is so cool because not only is this an alternate solution
;; using reduce, it also applies the apply logic to push the conj
;; into the group so that there is no need for a flatten!
#+end_src
There are a few other solutions that warrant a closer look:
#+begin_src clojure
;; keep is like map where nil results are filtered from the final answer
;; keep-indexed is like map-indexed where nil results are filtered and f
;; requires both an index and a value
((fn [c n]
   (keep-indexed ;; so %1 and %2 below are idx and item of the coll
     #(if (> (mod (inc %1) n) 0) %2) c))
 coll 3)
;; => (1 2 4 5 7 8)
;; if mod is > 0 keep the value in the list, so in this example every 3rd
;; item is kept and the rest are thrown out! A poor mans partition!

;; the partition-all solution is rather elegant as well
;; partition-all takes a partition size n, a step and a coll
;; partition-all keeps chunks that are smaller than the partition size
;; unlike partition-by which is "wasteful" and drops the extra
(partition-all (dec 3) 3 coll)
;; => ((1 2) (4 5) (7 8))
;; then apply concat slides into the groupings and stitches it all
;; back into a flat seq
(apply concat (partition-all (dec 3) 3 coll));; => (1 2 4 5 7 8)
;; i think the key piece is that partition size is 2 for this example
;; and step size is 3 so partion-all steps over the last item effectively
;; dropping it!
#+end_src

** [[https://www.4clojure.com/problem/42][#42 Factorial Fun]]
   Write a function that compute the factorial of the given number n:
#+begin_src clojure
;; thinking to use repeat here
(apply * (take 3 (repeat 3)))
;; => 27
;; which is nice but this is an exponential not a factorial!

;; what we need is the almighty range
(range 1 4);; => (1 2)
;; => (1 2 3)

(#(apply * (range 1 (inc %))) 3)
;; => 6

;; as simple as it gets, I like this solution for it's readability and directness
;; my first solution kind of amazes me in that it uses iterate...kinda proud of my
;; naive self!

((fn [n] (reduce * (take n (iterate inc 1)))) 3)
;; => 6

;; the following is a "poor mans" range!
(take 3 (iterate inc 1))
;; => (1 2 3)

;; a more convoluted recursive solution:
(#((fn fac [n r]
     (if (= n 1)
       r
       (fac (dec n) (* n r)))) % 1) 3)
;; => 6
#+end_src
These seem to be the major solutions that are out there! Onward!
** [[https://www.4clojure.com/problem/45][#45 Intro to Iterate]]
   What I thought iterate would output is ~(4 4 4 4 4)~, that is, just taking the function and making an infinite sequence out of it. What it actually outputs is ~(1 4 7 10 13)~ which is x, f(x), f(f(x), f(f(f(x))), etc. This very much looks like a versatile variation of ~reduce~ and I wonder if previous examples could be solved with it (for example #33 Replicate a sequence).
   A quick first attempt to see what iterate would look like gives me the impression that since iterate returns the first input as a result that this will either have to be stripped away, buuuut it does make me think of the fibonacci sequence where the initial values are a good candidate for the output
 #+begin_src clojure
 (take 5 (iterate #(+ 3 %) 1))
 ;; => (1 4 7 10 13)

 (+ 1 1);; => 2
 #+end_src

 #+begin_src clojure
   (take 2 (iterate #(repeat 4 %) [:a :b]))
   ;; => ([:a :b] ([:a :b] [:a :b] [:a :b] [:a :b]))

   ;; fib attempt
   (take 5 (iterate #(+ % %) 1))
   ;; => (1 2 4 8 16)
   ;; => (1 2 3 4 5)

   (#(take % (iterate (fn [[a b]] [b (+ a b)]) [1 1])) 8)
   ;; => ([1 1] [1 2] [2 3] [3 5] [5 8] [8 13] [13 21] [21 34])
   ;; => (1 1 2 3 5 8 13 21) after adding map first

   ;; first I don't think I understand the destructuring
   (let [[a b] [1 3]]
      (str a " " b))
   ;; => "1 3"
 #+end_src
     This keeps catching me out, when a vector is destructured to a vector the values are mapped to corresponding variable names so the above fib variation with iterate looks like return the vector that consists of the second input variable as the first result and the second result is the first input plus the second input, then feed that resulting vector into the same function so [1 1] -> [1 2] -> [2 3] -> [3 5] -> [5 8]
  I suppose the discover fiction might have gone like:
  1) first think about explaining exactly what the fib sequence is doing and pretend that there is a way to feed outputs of functions back to themselves iteratively.
  2) then somehow one has to know that the iterate function is exactly what fits that imagined patter (of course pure recursion is probably the simpler approach) but given that iterate does exist then map first through that generated sequence.
     For the discovery process to work it's important to think like feynman when he says It's ok not to know everything. Just move forward with the abstraction and take note of where you are stuck, the mind will create a kind of sieve that will make the solution pop out eventually!
** [[https://www.4clojure.com/problem/47][#47 Contain Yourself]]
   Using ~contains?~ on an indexed sequence takes the second argument to literally mean is index n in the sequence. However when used on a map or a map-like structure then ~contains?~ looks to see if the KEY is in the collection. Fun fact, I did not know until this exercise that a set is a map-like collection  but this makes sense to me in that a set can be thought of as a collection of keys, so key comparisons in ~contains~ returns true if key is in set.
** [[https://www.4clojure.com/problem/49][#49 Split a sequence]]
   Without using split-at, is a good clue to look at split-at but instead looking at the first params shows us that it's not an index to split at, instead it reads more like ~take~, as in ~take~ the first 3 and return the rest...like maybe ~cons~
#+begin_src clojure
(#(cons (take %1 %2) (vector (drop %1 %2))) 3 [1 2 3 4 5 6])
;; => ((1 2 3) (4 5 6))
(#(list (take %1 %2) (drop %1 %2)) 3 [1 2 3 4 5 6])
;; => ((1 2 3) (4 5 6))
((juxt take drop) 3 [1 2 3 4 5 6])
;; => [(1 2 3) (4 5 6)]
#+end_src
~juxt~ is especially interesting in that it takes left to right order and applies to the inputs so for something like juxt f(x) g(x), f is applied first to the inputs and then independently g is applied to the inputs and the results are returned as a tuple (f,g). This is related to comp however comp applies right to left (normal order) and pushes the inputs, in our above example this would look like applying function g and then pushing the results of function g into function f finally returning results.
** [[https://www.4clojure.com/problem/51][#51 Advanced Destructuring]]
   https://blog.brunobonacci.com/2014/11/16/clojure-complete-guide-to-destructuring/
** [[https://www.4clojure.com/problem/61][#61 Map Constructions]]
   Given two collections, make a map where the first coll are the keys and the second are the values without using ~zipmap~ : first thought ~map-indexed~ ... which is a weird first thought...
#+begin_src clojure
((fn [c1 c2]
   (map (fn [x] (assoc {}) ))) [:a :b :c] [1 2 3]);; => ()

(assoc {} :a 1)
;; => {:a 1}

(into [] [1] )
;; => [1]

(map (fn [x]
       (reduce
         (fn [acc y]
           (assoc acc x y))
         {}
         [1 2 3])
       )
     [:a :b :c])
;; => ({:a 3} {:b 3} {:c 3})

;; function map should accept coll-number-of-params! this makes sense now!
(map vector [1 2 3] [:a :b :c])
;; => ([1 :a] [2 :b] [3 :c])

(into (hash-map) [[1 :a] [2 :b] [3 :c]])
;; => {1 :a, 2 :b, 3 :c}

(map #(assoc {} %1 %2) [1 2 3] [:a :b :c])
;; => ({1 :a} {2 :b} {3 :c})

(into (hash-map) (map vector [1 2 3] [:a :b :c]))
;; => {1 :a, 2 :b, 3 :c}

(#(into (hash-map) (map vector %1 %2)) [:a :b :c] [1 2 3])
;; => {:a 1, :b 2, :c 3}
#+end_src
This was absolutely just about working in the REPL trying to build an intuition, I struggled with is and in some ways I'm not surprised as my familiarity with maps in clojure are not as strong as with vectors and lists...although I suspect that maps have some of the more unique features that clojure has to offer
Looking at other solutions:
#+begin_src clojure
;; using interleave, breaking it apart first
( #(interleave %1 %2) [:a :b :c] [1 2 3])
;; => (:a 1 :b 2 :c 3)
(apply hash-map '(:a 1 :b 2 :c 3));; => {:c 3, :b 2, :a 1}

;; i'm thinking that i just don't have a familiarity with hash-map
;; built up
(hash-map :a 1);; => {:a 1}
(apply hash-map [:a 1]) ;; => {:a 1}
(hash-map :a [:b 2])
;; => {:a [:b 2]}

;;so this is a very elegant solution
(#(apply hash-map (interleave %1 %2)) [:a :b :c] [1 2 3])
;; => {:c 3, :b 2, :a 1}

;;walking through the following since there is still some confusion about
;; how to effectively use map and reduce

((fn [k v] (assoc {} k v)) :a 1);; => {:a 1}

;;mapv is a map that returns a vector
(mapv (fn [k v] (assoc {} k v)) [:a :b :c] [1 2 3]);; => [{:a 1} {:b 2} {:c 3}]

;; and here is an example of reduce where the second value (a seq) is generated with
;; a map function...probably a common pattern
((fn [ks vs]
   (reduce conj {} (mapv (fn [k v] (assoc {} k v)) ks vs))) [:a :b :c] [1 2 3])
;; => {:a 1, :b 2, :c 3}
;; very cool and very fundamental usage where a sequence of values is almost
;; attached to the end of another function, which is reduce here ;)

;; a simpler version can be attached in the same place without using mapv
;; and perhaps using even simpler logic
(map (fn [k v] {k v}) [:a :b :c] [1 2 3]);; => ({:a 1} {:b 2} {:c 3})
;; this simpler form takes the key and value and places it into a map literal
;; instead of using assoc and mapv is not explicitly needed
(conj {} {:a 1});; => {:a 1}
;; however it is good to remind ourselves that reduce and map take a sequence
;; but they only evaluate it one time at a time, and so it is taken outside of
;; the sequence for evaluation (this is of course so obvious but noting it means
;; perhaps that I understand something is automatically given to us here -> almost
;; like a free ~apply~ if that makes sense)

;; we can take the exact seq generating function and use into instead of reduce
((fn [ks vs] (into {} (map (fn [k v] {k v}) ks vs))) [:a :b :c] [1 2 3]);; => {:a 1, :b 2, :c 3}
(into (into {} {:a 1}) {:b 2})
;; => {:a 1, :b 2}
;; into is still somewhat confusing to me so it's helpful to remember that it
;; uses conj to add the internal collection to the to-collection
;; in my mind conj seems like it is escaping the list or vector and applying
;; itself to the internals of the collection which is not what I'm used to
(conj () '(1 2 3))
;; => ((1 2 3))
;; however the differeGnce as saw above is that into uses reduce with conj
;; and internally into also uses reduce and conj together, this is why this is
;; confusing to me and now I see it! conj on it's own takes the entire collection
;; not just the internals and adds it to the to-collection!
;; anyhow a demonstration of this is below:
(into {} [{:a 1} {:b 2} {:c 3}])
;; => {:a 1, :b 2, :c 3}

;; merge is a useful function that literally combines two maps together, where
;; conflicting keys overwrite each other, the last key is the final result
(merge {:a 1} {:b 2} {:c 3})
;; => {:a 1, :b 2, :c 3}
;; so using reduce with the previous collection (list of maps or vector of maps)
;; will pluck the first two and then the final map and place it into a single map
;; very handy!
((fn [ks vs] (reduce merge (map (fn [k v] {k v}) ks vs))) [:a :b :c] [1 2 3]);; => {:a 1, :b 2, :c 3}
#+end_src

** [[https://www.4clojure.com/problem/62][#62 Implement Iterate]]
   I find ~iterate~ to be a very fascinating function. Implementing it will surely be instructive:
#+begin_src clojure
(take 5 ((fn iter [f v]
           (lazy-seq (cons v (iter f (f v))))) #(* 2 %) 1));; => 2
;; => (1 2 4 8 16)

;; when take is exhausted the last step is (cons v '()) so it all
;; returns back a list a values. I'm not entirely sure what lazy-seq is
;; doing but I forget to add it in my first attempt and it errored out in
;; and integer overflow, so I know in a hand-wavey manner that lazy-seq
;; only evaluates as needed I just don't know the finer details of how that's
;; accomplished, but for now, iterate looks so damn simple: apply the function
;; shift the output value into the input value and repeat!
#+end_src
There was only one other solution that I found which was different to my own:
#+begin_src clojure
;; my answer felt simple and clear, this looks like an alien cave drawing to me!
;; fun!
(fn [f x] (reductions #(%2 %1) x (repeat f)))

;; first reductions takes a function, an init value and a collection
;; so we must be building a collection of f with repeat...what does that look
;; like?

(take 5 (repeat #(* 2 %)))
;; => (
;; #function[user/eval7513/fn--7514]
;; #function[user/eval7513/fn--7514]
;; #function[user/eval7513/fn--7514]
;; #function[user/eval7513/fn--7514]
;; #function[user/eval7513/fn--7514]
;; )

;; so this works exactly as expected although a collection of fns is not something
;; that I think about so that's nice to see

;; next reductions says it returns a lazy-sequence, so check, we def need that
;; and it also returns the intermediate values of the reduction. So my
;; understanding of reductions is that it's what you use to see what
;; your reduce function is doing, like a utility function to "see" what the
;; compiler is doing to a collection but here we see that if you need
;; a lazy sequence of the intermediate steps reductions is the goto!

;; so again it's like reduce but instead of spitting out the final answer of
;; everything reduced down we get every answer of each reduce step in a sequence!
;; cool!

(take 5 ((fn [f v] (reductions #(%2 %1) v (repeat f))) #(* 2 %) 1))
;; => (1 2 4 8 16)

;; funny how the compiler will not let us nest anonymous functions but here
;; we have some kind of nesting so something special must be happening
;; however if we take out the shorthand ~#~ we still get the expected results

(take 5 ((fn [f v] (reductions (fn [acc x] (x acc)) v (repeat f))) #(* 2 %) 1))
;; => (1 2 4 8 16)

;; it is still absolutely mind-bendy where the function in the reductions call
;; is taking the collection producing function ~(repeat f)~ and ~v~ as the
;; function for the reduction, a bit inception-y and a sign that I still don't
;; have my recursion-sea-legs as I'm not sure I have the confidence that I would
;; think to do that

;; let's see if we can get a better idea of what is happening by taking it one step
;; at a time:

;; a note from the clojuredocs.org shows us that reductions can be thought of as
;; the following for loop:
(defn my-reduce
  [op init coll]
  (for [n (range (count coll))]
    (reduce op init (take (inc n) coll))))

(my-reduce + 1 [1 2 3])
;; => (2 4 7)

;; (reduce op  init (take 1 coll)) (+ 1 1) ;=> 2
;; (reduce op (take 2 coll)) (+ 1 1 2) ;=> 4
;; (reduce op (take 3 coll)) (+ 1 1 2 3) ;=> 7

;; so for our example we have an expanding list of functions

;; take 1 : fn = (#(*2 %)) and v = 1

;; because reduce is happening in the background %1 refers to the accumulator
;; and %2 is the next value in the sequence being reduced upon

;; take 2 : fn = (#(* 2 %) #(* 2 %)) and
;; I think the only way to understand this is to think of the % in the first
;; fn as slurping in the second fn so that we get a nesting of the functions
;; clearly something is confusing me about this step so perhaps I can break it
;; apart to understand it

(take 5 (lazy-seq (repeat (#(* 2 %) 1))))
;; => (2 2 2 2 2)
;; so here we're missing a step where the operator * is not gathering
;; together the results of each step, so this is not a good approximation of
;; what reductions is doing

;; it seems like it has to be the following:
;; when the initial value is given and an empty collection then the first result
;; is returned, when the initial value is threaded into a collection of functions
;; the values are built up one iteration at a time
(* 1) ;; => 1
(* 2 1) ;; => 2
(* 2 (* 2 1)) ;; => 4
(* 2 (* 2 (* 2 1))) ;; => 8
(* 2 (* 2 (* 2 (* 2 1)))) ;; => 16


;; this is similar but however the initial state of 1 is unreachable in this
;; example
(defn itera [arg] (* 2 arg))
(itera (itera (itera (itera 1))))
;; => 16

;; here is another attempt at this approximation using comp to feed the
;; initial value through a kind of pipeline of functions
((comp (fn [x] (* 2 x)) (fn [x] (* 2 x))) 1)
;; => 4

;; finally giving up and looking at the source of reductions shows that we are
;; using cons-recursion which plainly shows how we get the initial value first
;; and then the recursion lifts the function to the next call and so on
;; however this still does not completely satisfy my curiosity with the
;; collection of functions solution.
;;(cons init
;;      (lazy-seq
;;        (when-let [s (seq coll)]
;;          (reductions f (f init (first s)) (rest s)))))


((fn [v] (reductions
           (fn [acc x] (x acc))
           v
           [#(* 2 %) #(* 2 %) #(* 2 %)]
           )
   ) 1)
;; => (1 2 4 8)

;; reduce is like a window function right? so it takes the initial value and the
;; first value in the collection, this is exactly what I have not been
;; understanding! so it should look like this

;; ok so take create a seq of 5 anonymous functions then reductions goes to
;; work on them. What is not happening that was confusing me is that the
;; list of functions isn't dynamically growing with each step, like take 1
;; represents repeat creating a seq of one anon fn, take 2 is two anon funcs in a
;; seq etc. Take operates 5 times and reductions operates on a list of 5 fns
;; then reduce happens with the same reduce logic however the intermediate output
;; are given for each step and each step's result is carried forward!

;; 1st step just produces 1 is this how regular reduce works?
(reduce * 1 []) ;; => 1 ... cool, it does, learned something about reduce!
;; 2nd (#(* 2 %) 1) ;=> 2
;; 3rd (#(* 2 %) 2) ;=> 4
;; 4th (#(* 2 %) 4) ;=> 8 and so on

;; so as usual I was making it more complicated but in the process I discovered
;; more that I thought I understood but didn't...and now I do...sorta
#+end_src

** [[https://www.4clojure.com/problem/63][#63 Group a Sequence]]
   Given a function f and a sequence s, write a function which returns a map with the keys being the values of f applied to each item in s and the value should be a vector of the corresponding times grouped by the return value of f in the order they appear in s. Without using group-by...hmmm
#+begin_src clojure
;; so assoc can be used to build a map but does it also add to the same key
;; or add that key twice
(assoc {:a 1} :a 2)
;; => {:a 2}
;; ok so we need something that doesn't overwrite the last value but instead
;; adds to, like an upsert, perhaps rather than looking for something that does this
;; let's consider understanding how to roll our own version, seems like there's more
;; to learn through this kind of process

;; so contains? is exactly what we would want in terms of checking if a key exists
(contains? {:a [1]} :a)
;; => true
;; but we want the value so this is a possible branching situation
((fn [f s]
   (map (fn [x] (assoc {} (f x) [x])) s)) #(> % 5) [1 3 6 8])
;; => ({false [1]} {false [3]} {true [6]} {true [8]})

;; so it seems like ~merge-with~ allows us to define a function to determine how
;; values are dealt with when there is overlap
((fn [f s]
   (apply merge-with (fn [m1 m2] (into m1 m2)) (map (fn [x] (assoc {} (f x) [x])) s))) #(> % 5) [1 3 6 8])
;; => {false [1 3], true [6 8]}

;; can be slightly simplified to:
((fn [f s]
   (apply merge-with into (map (fn [x] (assoc {} (f x) [x])) s))) #(> % 5) [1 3 6 8]);; => {false [1 3], true [6 8]}
#+end_src
There aren't a lot of alternative solutions to this problem that I have found. However let's discuss two:
#+begin_src clojure
;; here is one using reduce, which of course can be used to solve any problem ;)
;; admittedly my understanding of maps in clojure especially the magic of their
;; seeming duality as functions is really what is interesting to me in this
;; solution.

;; So keep in mind that either a map or a keyword can be treated as a
;; function
({:a 1} :a) ;; => 1
(:a {:a 1}) ;; => 1
;; but if our map is not keyed by keywords we'd better stick to map-first as
;; a map-function!
({false 1} false);; => 1
(false {false 1}) ;; error!

((fn [f s]
   (reduce
    (fn [acc x]
      (let [k (f x) v (acc k)] ; a map is an fn which returns val or nil
        (if (nil? v) ; here we check if key k already exists
          (assoc acc k [x]) ; if no key already just add (wrap in vector)
          (assoc acc k (conj v x))))) ; otherwise build a vector of values in key
    {}
    s)) #(> % 5) [1 3 6 8])
;; => {false [1 3], true [6 8]}

;; the next solution is nice because it is almost the problems statement in english
;; but in code
((fn [f s]
   (apply merge-with concat (map #(hash-map (f %1) [%1]) s))) #(> % 5) [1 3 6 8])
;; => {true (6 8), false (1 3)}

(#(map (fn [x] (hash-map (%1 x) [x])) %2) #(> % 5) [1 3 6 8]);; => (1 3 6 8)
;; => ({false [1]} {false [3]} {true [6]} {true [8]})

;; just make a map out of f and sequence and then merge that map using concat when
;; there is a merge overlap!
#+end_src
** [[https://www.4clojure.com/problem/66][#66 GCD]]
   This is the kind of mathematical problem that I'm sure becomes very complex when performance is considered. My goal here is to outline a naive solution first seeing this as a demonstration of understanding modulo based arithmetic. First I think it is quite easy to build up a collection of even divisors for a number, but the second problem of finding the maximum number between two collections that is shared by the collection is new and interesting to me:
#+begin_src clojure
;; first let's familiarize ourself with the outputs of mod
(mod 4 3)
;; => 1

;; my favorite way of thinking about modulo math is the clock face
;; the above 4 mod 3 can be visualized by a clock face with numbers
;; a mod n where n is defined as the range 0 -> n - 1, so in our case
;; 0 .. 2
;;
;;   [imagine a clock face below]
;;               0
;;            2     1
;;
;; we see if we take 4 steps clockwise along this clock face
;; 0->1 step 1
;; 1->2 step 2
;; 2->0 step 3
;; 0->1 step 4 and our answer of 4 mod 3 is 1
;;
;; so what if we gather up all the numbers in a range from 1 to N
;; that give us mod 0, these would be the integer divisors of N
;;
;; then for many numbers we could compare that collection and build up
;; yet another collection of numbers that match for those, thereby giving
;; us the numbers that are the shared divisors for the given numbers
;;
;; then we simply take the max value of that final collection
;;
;; so then how do we compare two collections and only take the items that
;; match between the two?
;;
;; I suppose a terribly inefficient method would be ~doseq~ where we cycle one seq
;; through the other over and over and add the matching items into a new seq
(doseq [a [1 2 4 8]
        b [1 2 11 22]]
  (filter (fn [bx] (= a bx)) (vector b)))
;; => nil

;; so doseq's documentation mentions that the return value is always nil
;; which indicates that doseq should be used to cause side effects, aka
;; manipulate external variables which is not what we're trying to learn more
;; about here...next

(set [1 4 2 3 4])
;; => #{1 4 3 2}

((complement set) (concat [1 2 4 8] [1 2 11 22]))
;; => false

;; and complement is not going to give me a poor-man's intersection, complement
;; will only flip the boolean return value of a function ... trial by fire
;; learning edition
;; => #{1 4 3 2}

;; i bet a hacked way of double looping is with a reduce and a map

(reduce (fn [acc val]
          (into acc (keep (fn [x] (if (= val x) x)) [1 2 11 22])))
        []
        [1 2 4 8])
;; => [1 2]

;; this is short but not very descriptive to me, I know that keep will
;; filter all nils from a collection and the if-statement returns nil for any
;; non-match building up a sequence, keep filters that of all nils keeping only
;; the matching items from the seq...I'm certain there is a better way but ok
;; for this particular learning stage I suppose.

;; ok so we need to build up all the divisors that divide evenly into a number
;; and then "intersect them" and take the max

((fn [& nums]
   (let [ds (keep (fn [x]
                    (reduce (fn [acc val] (if (= (mod x val) 0)
                                            (conj acc val)
                                            (conj acc nil)))
                            []
                            (range 1 (inc x)))) nums)]
     ds))
 10 5)
;; => ([1 2 nil nil 5 nil nil nil nil 10] [1 nil nil nil 5])

;; nope. the keep needs to be the inner loop

((fn [n1]
   (keep (fn [x]
           (if (= (mod n1 x) 0)
             x
             nil))
         (range 1 (inc n1)))
   ) 10 )
;; => (1 2 5 10)

((fn [& nums]
   (map (fn [z]
          (keep (fn [x]
                  (if (= (mod z x) 0)
                    x
                    nil))
                (range 1 (inc z))))
        nums)
   ) 10 5)
;; => ((1 2 5 10) (1 5))

;; ok here's my first let statement (eye roll)

((fn [& nums]
   (let [ds (sort-by count #(> %1 %2) (map (fn [z]
                                             (keep (fn [x]
                                                     (if (= (mod z x) 0)
                                                       x
                                                       nil))
                                                   (range 1 (inc z))))
                                           nums))]
     ds)) 5 10)
;; => ((1 2 5 10) (1 5))

;; first time using a comparator to reverse the normal low -> high of sort
;; this is beyond getting messy but so close now I think!

((fn [& nums]
   (let [ds (sort-by count #(> %1 %2)
                     (map (fn [z]
                            (keep (fn [x]
                                    (if (= (mod z x) 0)
                                      x
                                      nil))
                                  (range 1 (inc z))))
                          nums))]
     (apply max (reduce (fn [acc val]
                          (into acc (keep (fn [x] (if (= val x)
                                                    x
                                                    nil)) (first ds))))
                        []
                        (second ds))))) 5 10)
;; => 5

;; what a messy but somehow gratifying solution!
#+end_src
Cringing a bit now that I've seen how short some of the answers are...lots to learn let's jump in!
#+begin_src clojure
;; so it turns out that with some light googling there is this thing
;; called the Euclidean Algorithm and it takes the problem of GCD I just
;; solved in a rather cumbersome method and makes it about as simple as
;; basic recursion can be...this maybe would have saved some time but
;; as always I don't regret the knowledge I've gained from working it out
;; the dumb way first!

((fn [x y]
   (loop [x x y y r (rem x y)]
     (if (= 0 r)
       y
       (recur y r (rem y r))))) 1023 858)

;; in short Euclid proved that GCD(270,192) = GCD(192,78) = ...
;; repeat and take the number just before zero or 1 (since every number
;; is ultimately divisible by 1)
(rem 270 192)
;; => 78
(rem 192 78)
;; => 36
(rem 78 36)
;; => 6
(rem 36 6)
;; => 0
;; so the GCD here is 6

;; almost every answer is similar to the above recursion except this caught my eye

(fn [x y]
  (apply max
         (filter #(= 0 (mod x %) (mod y %))
                 (range 1 (+ 1 (max (/ x 2) (/ y 2)))))))

(range 1 (+ 1 (max (/ 10 2) (/ 5 2))));; => (1 2 3 4 5)
;; this range seems to imply that with two numbers the maximum range you have
;; to check is if x or y in this case divide evenly into each other. Then you
;; check that range and filter out and take the max of the common factors from a
;; much shorter list ... so euclid still wins but this is nice to see as well.
#+end_src
** [[https://www.4clojure.com/problem/81][#81 Set Intersection]]
   Write a function which returns the intersection of two sets, the common items between 2 collections. I think I inadvertently already did this in the process of solving #66 GCD...I know there  must be a more functional way tho, let's see if I can find it:
#+begin_src clojure
;; off the top of my head I can think of something like using ~frequencies~ to
;; find and then take the keys of the frequency that return something greater than
;; 1...this would give me more experience using maps which is currently lacking

(#(frequencies (concat %1 %2)) #{0 1 2 3} #{2 3 4 5})
;; => {0 1, 1 1, 3 2, 2 2, 4 1, 5 1}

(keys (filter #(< 1 (second %)) {:a 1 :b 2 :c 3}))
;; => (:b :c)
;; => ([:b 2] [:c 3])

(#(keys (filter
          (fn [v] (< 1 (second v)))
          (frequencies (concat %1 %2))))
  #{0 1 2 3} #{2 3 4 5})
;; => ([3 2] [2 2]) -> then take just keys to produce below answer
;; => (3 2)

;; while looking at the filter documentation I discovered that filter can
;; take a set as a predicate with another set as the input to return the
;; the intersection of the two sets! I'm guessing that exposing this feature
;; is exactly the purpose of this exercise!

(#(filter %1 %2) #{0 1 2 3} #{2 3 4 5}) ;; => (3 2)

;; such an elegant emergent result!
#+end_src
There are a couple of solutions I'd like to document here:
#+begin_src clojure
;; a common solution involves using ~contains?~ which is powerful and
;; straight forward as long as one realizes that its designed to be used with
;; key-value based collections, maps and sets are an example of such colls
;; contains? can also be used with numberically indexed collections like vectors
;; and arrays but it will simply return the boolean status of the existence or non
;; existence of any value at that index, or more specifically if that index
;; exists within the range of indexes of the collection

((fn [s1 s2] (set (filter #(contains? s2 %) s1))) #{0 1 2 3} #{4 3 9 2})
;; => #{3 2}

;; this next solution I've included because I think it represents the same kind of
;; abusive relationship that I had with reduce in the solution to #66 GCD
;; reduce is used to build up a collection of items that I'd like dropped from
;; an already existing sequence...this mess of a reduce fn is familiar
;; to be clear, I'm not saying this is wrong, but I am saying that when an
;; existing sequence exists perhaps it is simpler to think about filter as
;; "building up the seq" rather than reduce

((fn [a b] (reduce #(if (contains? a %2) (conj %1 %2) %1) #{} b))
 #{1 2 0 7} #{6 2 7 3})
;; => #{3 2}

;; at first I thought that this above solution would not work because in the
;; if-branch, the false branch replaces the reduce accumulator with #{} buuut
;; what actually happens is that %1 and %2 start off referring to #{} and b
;; but then %1 specifically references the accumulator that changes with
;; each successive iteration! Not obvious to me at first, so %1 becomes the
;; accumulator and the false branch simply says "pass the accumulated result
;; back without any additions". I think I needed this magic in my #66 solution.
#+end_src
** [[https://www.4clojure.com/problem/83][#83 A half truth]]
   Function should return true if some but not all of the params are true, all false is false, all true is false, some true is true, sounds like I should investigate ~and~ : and looks stops on false and returns that value, if and makes it to the end it returns the final value. Or stops on true evaluations and returns the value or makes it to the end and returns the last value.
   More succinctly put, and continues with true, or continues with false
#+begin_src clojure
;; various forms of and applied to sequence
(and true false nil)
;; => false
;; => nil
;; => false
;; => 4

;; still having trouble applying and to a collection
((fn [& d] (and false true false)) false true false)
;; => false

;; here is just my logic templated out short circuiting that problem of applying
;; and to a collection
((fn [& c] (and (= (and false true false) false) (= (or false true false) true))) false true false)
;; => true
;; => false
;; => false
#+end_src
So it turns out that using ~apply~ with ~and~ or any other macro is a big fail, I have marked this particular issue as something to figure out once I am more knowledgeable about how to write a macro and what is specifically happening but it is good to note this behaviour for now.
However there may be more luck using ~every~ and ~not-every
#+begin_src clojure
(every? identity '(false true false))
;; => false
(not-every? true? '(false true false))
;; => true
(every? identity '(false false false))
;; => false
(every? identity '(true true true))
;; => true
((fn [& c] (and (not-every? false? c) (not-every? true? c))) true  false true)
;; => true

;; this is almost an english sentence in terms of how clear it is

#+end_src
Some of the difficulties that I had were that I had to remember how to take multiple individual inputs and scoop them up into a collection. This is what the [& c] is for, however I had never seen that without a first variable such as [a & c] so I did not know that the &c would be the entire sequence if there was no preceding variables, great to note! The rest of my difficulty was that I did not know that you cannot ~apply~ a macro and ~and~ and ~or~ are macros, so I ditched those macros and used not-every? which turned out to read more clearly to me. One solution I found as simple as mine but using slightly different funcs:
#+begin_src clojure
((fn [& xs]
   (true? (and (some true? xs) (some false? xs)))) true false true)
;; => true
;; this is equivalent to what I used with not-every? however it's arguably
;; even more readable as some true some false shoulder shrug? almost like
;; and idiom or like comme ci comme ca in french
((fn [& xs]
   (and (some true? xs) (some false? xs))) false false)
;; => nil
;; => nil
;; thinking to try to remove the first true? reveals that all true or false
;; returns nil
(some true? '(false false));; => nil
;; which is exactly how some works so in this particular case I believe my answer
;; with not-every? is even more clear than this example and shorter without them
;; extra true? evaluation -- party!
#+end_src

** [[https://www.4clojure.com/problem/88][#88 Symmetric Difference]]
   The symmetric difference is the set of items that belong to one but not both of two sets:
#+begin_src clojure
;; ok so calling set on a collection removes duplicate, only takes said unique
;; values
(set [1 2 3 3 5 2 5])
;; => #{1 3 2 5}
;; so what we want here are items that are only in one set but not the other
;; one interesting idea is that using a set as a filter's predicate gives us
;; the intersection of two sets (which is something I was looking for in #66 GCD)
(filter #{1 2 3} #{1 2 4 6})
;; => (1 2)
;; but what we would have wanted from the above is #{3 4 6}, so we want to eliminate
;; (1 2) from both and return what remains
(filter (complement #{1 2 3}) #{1 2 4 6})
;; => (4 6)
;; this is kind of lucky for me to stumble upon this, here we are treating
;; #{1 2 3} as a function that returns true if it matches and flipping that
;; to be the opposite, but this is still not the answer because 3 is not considered
;; part of the collection we are filtering, instead it is part of the function
;; we are using to determine what to filter, we can change that by computing
;; the intersection of the two sets and using that as the function for both
((fn [s1 s2]
   (set (filter
          (complement (set (filter s1 s2)))
          (concat s1 s2))))
 #{1 2 3} #{1 2 4 6})
;; => #{4 6 3}
;; this is rather cool to me, filter on two sets gives me the intersection of the
;; two sets, then making that result into a set allows me to use the resulting
;; intersection to filter the concatenation of both sets, thereby giving me the
;; so called symmetric difference -- my brain is spaghetti!


#+end_src
After reviewing some other solutions I was shocked that almost all of them used the core set functions while I've been limiting myself to only the direct clojure core namespace and no other sibling or child namespaces:
#+begin_src clojure
;; most solutions looked like some variation of the following:

((fn [s1 s2]
   (into
     (clojure.set/difference s1 s2)
     (clojure.set/difference s2 s1))) #{1 2 3} #{1 2 4 6})
;; => #{4 6 3}

;; or

#(clojure.set/union
   (clojure.set/difference %1 %2)
   (clojure.set/difference %2 %1))

;; which are undoubtedly clearer and perhaps even more correct as my solution seems
;; to use a number of tricks (but I'm glad of course to know of them!)

;; this serves to help me understand that I can be a little less strict about
;; what "clojure core" libraries are available for these problems at the very least
;; in the interest of examining more of the basic building blocks of clojure

;; the final solution I'll look into is another that avoids using the set namespace

((fn [s1 s2] (into (apply disj s1 s2) (apply disj s2 s1))) #{1 2 3} #{1 2 4 6})
;; => #{4 6 3}

;; at first glance I thought disj was dissoc however it seems that disj is
;; specific to hashed sets and dissoc is specific to maps, otherwise I'm
;; guessing that drop and rest etc are the functions used to trim vectors and
;; other vector-like sequences
#+end_src
** [[https://www.4clojure.com/problem/90][#90 Cartesian Product]]
   Cartesian products are the combination of the value of the first index in set one with all values of set 2, then the second index of set 1 with all the values of set 2 etc, this is a for loop or a doseq:
#+begin_src clojure
(#(into #{} (for [x %1
                  y %2] [x y])) #{1 2 3} #{4 5})
;; => #{[2 5] [3 4] [1 4] [1 5] [2 4] [3 5]}

;; so of course I'm curious about if I could use doseq here and what are the
;; differences, and the difference is that the sequence is not returned with
;; doseq, so it would be for performing some side-effect on every value of
;; the sequence produced (like saving in a db or printing) and for returns the
;; sequence that was generated...also for is lazy and doseq is "eager" or
;; executes all values at once
#+end_src
Looking at the solutions doesn't reveal any answers that surprised me except that I should mention that most other answers simply called ~set~ on the final solution rather than ~into~ which makes sense.

** [[https://www.4clojure.com/problem/97][#97 Pascal's Triangle]]
   Write a function which returns the nth row of pascals triangle, since the wikipedia page is given I will wholeheartedly look up what I need from there! Looks like we can calculate the row n and columns k with:
   (n k) = (n k-1) x (n + 1 - k / k ). This took me a second to realize that what the (n k-1) is referring to the previous answer and (n 0) = 1, so the first answer is always 1 it kind of an identity and the fact that it is a surprise just shows that I don't fully understand it yet but hey, starting somewhere. Then one simply goes through from left to right where n is constant since we are calculating a row and key increments until k = n...I think I have enough to attempt a solution:
#+begin_src clojure
;; so we are given an n as the row index or multiple rows and we want to return
;; the values for the columns of each row wrapped in a vector or sequence probably
;; the row contains n columns as well, so row one has 1 column, row 11 has 11
((fn [n] (reduce (fn [acc k] (if (or (= k 0) (= k (dec n)))
                               (conj acc 1)
                               (conj acc (* (/ (- n k) k) (last acc)))))
                 []
                 (range n)))
 5)
;; => [1 4 6N 4N 1]
(type (* (/ 3 2) 4));; => 3/2
;; => clojure.lang.BigInt
;; => 6N
;; so that clears up why the N is there to indicate that it's not a java.lang.Long
;; but more specifically a clojure.lang.BigInt
;; when numbers are followed by an M that indicates that its a java.math.BigDecimal
(type 1M);; => java.math.BigDecimal
;; I would say my answer is very straight forward and somewhat linear in terms of
;; breaking things apart...easy to parse for a beginner I would hope
#+end_src
I wanted to add that this video helped me to understand what the binomial (n 0) = 1 means [[https://www.youtube.com/watch?v=_hrN4rVCOfI][Intuitive connection between binomial expansion and combinatorics | Algebra II | Khan Academy]]

A few of the solutions are more elegant than my own including one that uses a macro which  I'm excited to review:
#+begin_src clojure
;; this looks very similar to my answer but does not have the if statement
;; so it's worth taking a minute to unpack that design
(fn [i]
  (reduce
    #(conj %1 (* (last %1) (/ (- i %2) %2)))
    [1] (range 1 i)))
;; given an i = 5 we see that having a [1] as the first arg
;; already skips the step of needing the first branch of my answers if statement
;; by simply allowing the 1 to always be the first item in the collection, a
;; totally valid assumption. After seeing this I immediately removed the
;; second case of my solutions or statement and found that the last boundary
;; is calculated correctly...so that's how we get rid of the if statement entirely
;; assume the 1 is there by definition (which mathematically it is and it makes
;; sense now)
;; the rest of the answer is identical to my own and the binomial equation given
;; in wikipedia although using %1 %2 instead of n and k for the variable names
;; is more confusing for someone coming in without knowing the equation

;; the final solution I'd like to review is one with an inline macro which will
;; be the first time I am picking apart a macro!

(fn [n]
  (last (take n (iterate
                  #(map +' `(0 ~@%) `(~@% 0))
                  [1]))))

;; not sure what +' means: similar to + but supports arbitrary precision
;; so the following taken from clojuredocs explains more
(class 1)
;; => java.lang.Long

(+ 1 Long/MAX_VALUE)
;; => java.lang.ArithmeticException: integer overflow
;;        Numbers.java:1388 clojure.lang.Numbers.throwIntOverflow
;;        Numbers.java:1687 clojure.lang.Numbers.add

(+' 1 Long/MAX_VALUE)
;; => 9223372036854775808N

(class (+' 1 Long/MAX_VALUE))
;; => clojure.lang.BigInt

;; after experimenting with the solution without +' and simply + the answer
;; still worked but +' seems to be saying, go ahead and throw huge numbers at
;; me, I'm ready!

;; then we have two syntax quotes around forms indicating that the two forms
;; `(0 ~@%) and `(~@% 0) will not be evaluated but instead sent as forms
;; however the Unquoting Splice indicates that we expect a collection
;; to be passed in and the collection will be spliced into the quoted result
;; so this is fancy let's break it down
;; iterate returns the input first so the first is [1]
;; the second output is the f(x) which would look something like:
(map + '(0 1) '(1 0)) ;; => (1 1)
;; building on this
(#(map + `(0 ~@%) `(~@% 0)) [1]);; => (1 1)
(#(map + `(0 ~@%) `(~@% 0)) [1 1]);; => (1 2 1)
(#(map + `(0 ~@%) `(~@% 0)) [1 2 1]);; => (1 3 3 1)
(#(map + `(0 ~@%) `(~@% 0)) [1 3 3 1]);; => (1 4 6 4 1)
;; I see! this is exactly how the general pascal triangle equation works
;; in a visual way, with zeros that aren't written on the outer edges of the
;; triangle. One way to compute a row for example the row below the [1 1] level
;; is to imagine that the row contains two zeros so it is [0 1 1 0], then for the
;; row below we would:
;; add idx 0 + idx 1 of the row to get 0 + 1 = 1
;; add idx 1 + idx 2 of the row to get 1 + 1 = 2
;; add idx 2 + idx 3 of the row to get 1 + 0 = 1

;; this solution is super elegant, hats of to user https://gist.github.com/SegFaultAX damn!

;; this also builds some intuition on how to know when to use iterate
;; if you can build up the solution by constantly feeding the results of a
;; single function back to itself, wow this is cool!
#+end_src

** [[https://www.4clojure.com/problem/99][#99 Product Digits]]
   Write a function that multiplies two numbers and then returns the results as a sequence of the individual digits 1 * 10 = 10 but we want [1 0]
#+begin_src clojure

(seq (str (* 9 99)));; => (\8 \9 \1)
(int \8);; => 56
(int \0);; => 48
(- 56 48);; => 8
(#(map (fn [x] (- (int x) (int \0))) (seq (str (* %1 %2)))) 9 99)
;; => (8 9 1)

;; I got as far as converting from int to str and had to look up an answer
;; to learn that char 8 minus char 0 will give us the integer value back
;; this is likely the kind of thing that I will always have to look up
#+end_src
This problem required some outside understanding of how an ascii char table is guaranteed to be laid out:
Because the C standard guarantees that the characters 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 are always in this order regarding their numerical character code. So, if you subtract the char code of '0' from another digit, it will give its position relative to 0, which is its value...

From the C standard, Section 5.2.1 Character sets:

In both the source and execution basic character sets, the value of each character after 0 in the above list of decimal digits shall be one greater than the value of the previous

This at least makes some logical sense but I wasn't excited that this answer depended on that, however similar answers used parseint which I will cover below:
#+begin_src clojure
;; I'm very shaky on my understanding of Java interop, so I'm not
;; really sure what's really available

((fn [a b]
   (map #(Integer/parseInt (str %)) (str (* a b)))) 9 99)
;; => (8 9 1)

(type (str (* 9 99)))
;; => java.lang.String
;; so the first result returns a string but then when passing it in to %
;; it is a char which is incompatible with parseInt hence the extra conversion
;; not super elegant to me but hey...


;; using read-string takes a string but then somehow tries to return a precise
;; type, this must be why it can be used with eval or to execute code
(type (read-string "5.5"))
;; => java.lang.Double
(+ 1 (read-string "5.5"))
;; => 6.5

;; but again, a string is a sequence of chars so we have to reconvert it back to
;; a string for read-string but otherwise this avoids having to remember that the
;; ascii table is ordered incrementally for numbers and so number math and ascii
;; value math aligns...instead with read-string we simply get an integer back
((fn [x y]
   (map #(read-string (str %))
        (str (* x y)))) 9 99)
;; => (8 9 1)
#+end_src
** [[https://www.4clojure.com/problem/107][#107 Simple Closures]]
   This is a very simple example of lexical scope, that is, scope defined internally to a function or inside a let form for example. In this example we are asked to define a function that returns a function, thereby we can see that passing in args in one scope are closed-over and passed on in a sense to the inner function.
#+begin_src clojure
(((fn [n] (fn [x] (apply * (repeat n x))))  8) 2)
;; => 256

;; here we see that n still has a valid value inside the returned function
;; it has been captured into the inner scope. This problem is not really about
;; using various different methods to achieve simpler and clearer results (as
;; I have taken from previous challenges) but instead to concretely demonstrate
;; what scope looks like possibly in a way that such simple concept can be
;; taken and applied to other problems
#+end_src

** [[https://www.4clojure.com/problem/122][#122 Read a Binary Number]]
   Take a string of numbers and compute the number where the bits are calculated as powers of 2: so 1001 = 9 because 2^3 + 0 + 0 + 2^0 = 8 + 1. So maybe a way to approach this is with map-index and reversing the string then summing up:
#+begin_src clojure
(#(apply + (map-indexed (fn [idx x] (if (= x \1)
                                      (apply * (repeat idx 2))
                                      0))
                        (reverse %))) "10101010101")
;; => 1365

;; was nice to have already dealt with converting chars to ints even though this
;; didn't come up here it did still give me a little confidence that I wouldn't
;; get stuck on something like that. This was all very clear to me and went rather
;; smoothly ¯\_(ツ)_/¯
#+end_src
There is an even clearer solution that involves java interop...but of course since I don't know basic java this wouldn't pop out at me so it's worth documenting here:
#+begin_src clojure
(#(Integer/parseInt % 2) "1001")
;; => 9
;; this works because the second argument of parseInt takes the radix of the
;; number, so that parsing can also be a conversion to a number system, like
;; for instance hexadecimal or radix 16
#+end_src
** [[https://www.4clojure.com/problem/126][#126 Through the looking Class]]
   I'm not even sure what I'm looking at here:
#+begin_src clojure
;; the problem is to satisfy the following:
(let [x java.lang.Class]
  (and (= (class x) x) x))
;; => java.lang.Class

;; so my first question is what is class and what does it return?
;; and as per the docs it says that it returns the class of an object
;; which I assume means the java based class for the under written java object

;; my first thought which was:
(class class)
;; => clojure.core$class
(class (class class))
;; => java.lang.Class

;; I'm not sure...what the class of something equals itself?
(= (class ,,,) ,,,)
;; oh ok
(class java.lang.Class);; => java.lang.Class
;; but trying java.lang.Class gives an error so just using
(class Class);; => java.lang.Class

;; not entirely sure what java.lang.Class works here in emacs but not
;; in the 4Clojure browser test but x equals Class or java.lang.Class is the
;; correct answer and I'm not super sure what I'm supposed to get from this?
#+end_src
** [[https://www.4clojure.com/problem/135][#135 Infix Calculator]]
   Write a higher order function that allows infix math assuming no precedence and only left to right calculation
#+begin_src clojure
;; my first thought is to split this into two collections one that is the
;; math functions and the other that are the numbers but now I'm wondering if
;; I can just reduce this
(#(reduce (fn [acc x] (x acc)) (first %&) %&) 2 + 5)
;; errors out trying to use a number as a function...

;; so that doesn't work but what if I grouped the sequence into
;; operand operator operand groups? so the sequence would look something like:
;; given
(38 + 48 - 2 / 2)
(38 + 48) ;; operate and take result as r
(r - 2) ;; operate take accumulated r
(r / 2) ;; fin return r
;; or maybe groups of two and use reduce since there is already an accumulator
(partition 2 (drop 1 '(38 + 48 - 2 / 2)))
;; => ((+ 48) (- 2) (/ 2))

;; ok I think we can work with this but it's kinda messy
;; but the accumulator should always be a number
(#(reduce
    (fn [acc v] ((first v) acc (second v)))
    (first %&)
    (partition 2 (drop 1 %&))) 38 + 48 - 2 / 2)
;; => 42
;; I don't think I'd be bragging about this one "making infix possible"
;; especially considering the lack of precedence
#+end_src
I think my answer is in nice in that reduce can solve anything...not really but mayyyyybeee? Anyhow let's look at a solution that is arguably more idiomatic:
#+begin_src clojure
;; I find this solution more satisfying at first glance because I struggle to
;; use partial, plus shorter is better right?
((fn calc [& s]
   (reduce
     #(if (fn? %1) ; here the if statement lets us reorder the items if one is an fn
        (%1 %2) ; if accum is an fn no prob just use fn on %2
        (partial %2 %1)) ; however if not, switch order -- is partial necessary?
     identity ; identity passes the first item in the list like a bootstrap stage
     s)) ; and s is making a sequence out of the input
 38 + 48 - 2 / 2)

;; it seems that partial is very much necessary here because if we step through
;; we get something like this
;; is identity an fn -> true, apply identity to 38 returns 38 in accumulator
;; %1 then is 38 and %2 is +
;; we could switch the fn plus to the first part but (+ 38);; => 38
;; thereby we would be leaving out the 48 and loosing a reference to +
;; so without partial this step would return 38 again! uh oh!
;; that's valid our crash comes next when we have 38 as %1 and 48 as %2
;; we cannot number a number, there is no function we've lost the ref to +
;; so it is really really nice to have something like partial which returns
;; a function!
;; so our 2nd step with partial we have 38 is %1 and + is %2, and
;; partial + 38 returns a function to the accumulator, so cool!
;; the next step %1 is an fn and %2 is 48 so we simply combine the two and
;; place 86 into the accumulator and we repeat, this time making a partial
;; fn out of - and 86 and so on and so on. I don't think I would have fully
;; appreciated the use of partial here without this walk through, cheers!
#+end_src
** [[https://www.4clojure.com/problem/143][#143 Dot Product]]
   Map can take two collections and combines each index from c1 & c2 in ascending order idx1,ixd2...idxN. I'm guessing that's all we really need here:
#+begin_src clojure
(#(apply + (map * %1 %2)) [1 2 3] [4 5 6])
;; => 32
#+end_src
Interested to see any solutions that might show alternative methods...and I didn't find any. Very rare!
** [[https://www.4clojure.com/problem/157][#157 Indexing Sequences]]
   Transform a sequence into a sequence of pairs containing the original elements along with their index...seems like a map-index kinda problem:
#+begin_src clojure
(#(map-indexed (fn [idx x] [x idx]) %) [:a :b :c])
;; => ([:a 0] [:b 1] [:c 2])

;; there was only one other solution that I wanted to document:

(#(map vector % (range)) [:a :b :c]);; => ([:a 0] [:b 1] [:c 2])

;; which is nice just because it shows just how easy it is to manipulate
;; the generation of an infinite sequence!
#+end_src

** [[https://www.4clojure.com/problem/166][#166 Comparisons]]
   This problem states that the comparison operations < > != = etc can derived from a single operation excluding = and !=. We're asked to write a function that takes 3 args, the less than operator for the data, and two items to compare and then return a keyword describing the relationship between the items namely x and y. If
   x = y -> :eq
   x > y -> :gt
   x < y -> :lt
My first guess is this could be done by testing various outputs of the function by swapping the items under comparison and returning a keyword...something like cond or condp?
#+begin_src clojure
;; since the f passed in is supposed to represent the less than for the items
;; if we swap the items and compare the results we should be able to determine
;; the relationship between x and y
((fn [f x y]
   (cond
     (= true (and (= false (f x y)) (= false (f y x)))) :eq
     (= true (f x y))                                   :lt
     (= false (f x y))                                  :gt))
 > 0 2)

;; so the logic here is to provide a gateway test and then basically an
;; either or test
#+end_src
One shorter answer, at least, exists
#+begin_src clojure
(fn compare [f x y]
  (cond
    (f x y) :lt
    (f y x) :gt
    :else   :eq
    ))

;; this is essentially my solution but loads clearer
#+end_src
